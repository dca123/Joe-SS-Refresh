import {
  DMMF,
  DMMFClass,
  Engine,
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  sqltag as sql,
  empty,
  join,
  raw,
  Sql,
  Decimal,
} from '@prisma/client/runtime';

export { PrismaClientKnownRequestError }
export { PrismaClientUnknownRequestError }
export { PrismaClientRustPanicError }
export { PrismaClientInitializationError }
export { PrismaClientValidationError }
export { Decimal }

/**
 * Re-export of sql-template-tag
 */
export { sql, empty, join, raw, Sql }

/**
 * Prisma Client JS version: 2.10.2
 * Query Engine version: 7d0087eadc7265e12d4b8d8c3516b02c4c965111
 */
export declare type PrismaVersion = {
  client: string
}

export declare const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export declare type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export declare interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export declare type JsonValue = string | number | boolean | null | JsonObject | JsonArray

/**
 * Same as JsonObject, but allows undefined
 */
export declare type InputJsonObject = {[Key in string]?: JsonValue}
 
export declare interface InputJsonArray extends Array<JsonValue> {}
 
export declare type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray

declare type SelectAndInclude = {
  select: any
  include: any
}

declare type HasSelect = {
  select: any
}

declare type HasInclude = {
  include: any
}

declare type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose `select` or `include`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export declare type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export declare type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export declare type Enumerable<T> = T | Array<T>;

export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T]

export declare type TruthyKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

export declare type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PrismaClientFetcher {
  private readonly prisma;
  private readonly debug;
  private readonly hooks?;
  constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
  request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
  sanitizeMessage(message: string): string;
  protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}


/**
 * Client
**/

export declare type Datasource = {
  url?: string
}

export type Datasources = {
  db?: Datasource
}

export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your prisma.schema file
   */
  datasources?: Datasources

  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat

  /**
   * @example
   * ```
   * // Defaults to stdout
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events
   * log: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * ]
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: Array<LogLevel | LogDefinition>
}

export type Hooks = {
  beforeRequest?: (options: {query: string, path: string[], rootField?: string, typeName?: string, document: any}) => any
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
  GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
  : never

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findOne'
  | 'findMany'
  | 'findFirst'
  | 'create'
  | 'update'
  | 'updateMany'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'

/**
 * These options are being passed in to the middleware as "params"
 */
export type MiddlewareParams = {
  model?: string
  action: PrismaAction
  args: any
  dataPath: string[]
  runInTransaction: boolean
}

/**
 * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
 */
export type Middleware<T = any> = (
  params: MiddlewareParams,
  next: (params: MiddlewareParams) => Promise<T>,
) => Promise<T>

// tested in getLogLevel.test.ts
export declare function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Students
 * const students = await prisma.student.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export declare class PrismaClient<
  T extends PrismaClientOptions = PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<LogLevel | LogDefinition> ? GetEvents<T['log']> : never : never
> {
  /**
   * @private
   */
  private fetcher;
  /**
   * @private
   */
  private readonly dmmf;
  /**
   * @private
   */
  private connectionPromise?;
  /**
   * @private
   */
  private disconnectionPromise?;
  /**
   * @private
   */
  private readonly engineConfig;
  /**
   * @private
   */
  private readonly measurePerformance;
  /**
   * @private
   */
  private engine: Engine;
  /**
   * @private
   */
  private errorFormat: ErrorFormat;

  /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Students
   * const students = await prisma.student.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */
  constructor(optionsArg?: T);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * @deprecated renamed to `$on`
   */
  on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * Connect with the database
   */
  $connect(): Promise<void>;
  /**
   * @deprecated renamed to `$connect`
   */
  connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;
  /**
   * @deprecated renamed to `$disconnect`
   */
  disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw<T = any>(query: string | TemplateStringsArray | Sql, ...values: any[]): Promise<number>;

  /**
   * @deprecated renamed to `$executeRaw`
   */
  executeRaw<T = any>(query: string | TemplateStringsArray | Sql, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw<T = any>(query: string | TemplateStringsArray | Sql, ...values: any[]): Promise<T>;
 
  /**
   * @deprecated renamed to `$queryRaw`
   */
  queryRaw<T = any>(query: string | TemplateStringsArray | Sql, ...values: any[]): Promise<T>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): StudentDelegate;

  /**
   * `prisma.name`: Exposes CRUD operations for the **Name** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Names
    * const names = await prisma.name.findMany()
    * ```
    */
  get name(): NameDelegate;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): AddressDelegate;

  /**
   * `prisma.phoneNumber`: Exposes CRUD operations for the **PhoneNumber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhoneNumbers
    * const phoneNumbers = await prisma.phoneNumber.findMany()
    * ```
    */
  get phoneNumber(): PhoneNumberDelegate;

  /**
   * `prisma.emailAddress`: Exposes CRUD operations for the **EmailAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailAddresses
    * const emailAddresses = await prisma.emailAddress.findMany()
    * ```
    */
  get emailAddress(): EmailAddressDelegate;

  /**
   * `prisma.finance`: Exposes CRUD operations for the **Finance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Finances
    * const finances = await prisma.finance.findMany()
    * ```
    */
  get finance(): FinanceDelegate;

  /**
   * `prisma.announcement`: Exposes CRUD operations for the **Announcement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcement.findMany()
    * ```
    */
  get announcement(): AnnouncementDelegate;

  /**
   * `prisma.actionItem`: Exposes CRUD operations for the **ActionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActionItems
    * const actionItems = await prisma.actionItem.findMany()
    * ```
    */
  get actionItem(): ActionItemDelegate;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): ContactDelegate;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): ClassDelegate;

  /**
   * `prisma.teacher`: Exposes CRUD operations for the **Teacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teacher.findMany()
    * ```
    */
  get teacher(): TeacherDelegate;
}



/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export declare const StudentDistinctFieldEnum: {
  id: 'id',
  studentID: 'studentID',
  profilePicURL: 'profilePicURL',
  creditsCompleted: 'creditsCompleted',
  gender: 'gender',
  dob: 'dob',
  birthCountry: 'birthCountry',
  birthState: 'birthState',
  maritialStatus: 'maritialStatus',
  militaryStatus: 'militaryStatus',
  citizenshipStatus: 'citizenshipStatus',
  citizenshipCountry: 'citizenshipCountry',
  visaType: 'visaType',
  visaPermit: 'visaPermit',
  visaCountry: 'visaCountry',
  financeId: 'financeId',
  advisorId: 'advisorId'
};

export declare type StudentDistinctFieldEnum = (typeof StudentDistinctFieldEnum)[keyof typeof StudentDistinctFieldEnum]


export declare const NameDistinctFieldEnum: {
  id: 'id',
  name: 'name',
  type: 'type',
  studentId: 'studentId'
};

export declare type NameDistinctFieldEnum = (typeof NameDistinctFieldEnum)[keyof typeof NameDistinctFieldEnum]


export declare const AddressDistinctFieldEnum: {
  id: 'id',
  type: 'type',
  address: 'address',
  studentId: 'studentId'
};

export declare type AddressDistinctFieldEnum = (typeof AddressDistinctFieldEnum)[keyof typeof AddressDistinctFieldEnum]


export declare const PhoneNumberDistinctFieldEnum: {
  id: 'id',
  type: 'type',
  number: 'number',
  ext: 'ext',
  country: 'country',
  preferred: 'preferred',
  studentId: 'studentId'
};

export declare type PhoneNumberDistinctFieldEnum = (typeof PhoneNumberDistinctFieldEnum)[keyof typeof PhoneNumberDistinctFieldEnum]


export declare const EmailAddressDistinctFieldEnum: {
  id: 'id',
  type: 'type',
  address: 'address',
  preferred: 'preferred',
  studentId: 'studentId'
};

export declare type EmailAddressDistinctFieldEnum = (typeof EmailAddressDistinctFieldEnum)[keyof typeof EmailAddressDistinctFieldEnum]


export declare const FinanceDistinctFieldEnum: {
  id: 'id',
  accountBalance: 'accountBalance'
};

export declare type FinanceDistinctFieldEnum = (typeof FinanceDistinctFieldEnum)[keyof typeof FinanceDistinctFieldEnum]


export declare const AnnouncementDistinctFieldEnum: {
  id: 'id',
  title: 'title',
  detail: 'detail',
  imageUrl: 'imageUrl'
};

export declare type AnnouncementDistinctFieldEnum = (typeof AnnouncementDistinctFieldEnum)[keyof typeof AnnouncementDistinctFieldEnum]


export declare const ActionItemDistinctFieldEnum: {
  id: 'id',
  title: 'title',
  detail: 'detail',
  completed: 'completed',
  studentId: 'studentId'
};

export declare type ActionItemDistinctFieldEnum = (typeof ActionItemDistinctFieldEnum)[keyof typeof ActionItemDistinctFieldEnum]


export declare const ContactDistinctFieldEnum: {
  id: 'id',
  primary: 'primary',
  name: 'name',
  relationship: 'relationship',
  number: 'number',
  ext: 'ext',
  country: 'country',
  studentId: 'studentId'
};

export declare type ContactDistinctFieldEnum = (typeof ContactDistinctFieldEnum)[keyof typeof ContactDistinctFieldEnum]


export declare const ClassDistinctFieldEnum: {
  id: 'id',
  name: 'name',
  code: 'code',
  title: 'title',
  days: 'days',
  time: 'time',
  location: 'location',
  teacherId: 'teacherId'
};

export declare type ClassDistinctFieldEnum = (typeof ClassDistinctFieldEnum)[keyof typeof ClassDistinctFieldEnum]


export declare const TeacherDistinctFieldEnum: {
  id: 'id',
  email: 'email',
  name: 'name'
};

export declare type TeacherDistinctFieldEnum = (typeof TeacherDistinctFieldEnum)[keyof typeof TeacherDistinctFieldEnum]


export declare const SortOrder: {
  asc: 'asc',
  desc: 'desc'
};

export declare type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]



/**
 * Model Student
 */

export type Student = {
  id: number
  studentID: number
  profilePicURL: string
  creditsCompleted: number
  gender: string
  dob: string
  birthCountry: string
  birthState: string
  maritialStatus: string
  militaryStatus: string
  citizenshipStatus: string
  citizenshipCountry: string
  visaType: string
  visaPermit: string
  visaCountry: string
  financeId: number | null
  advisorId: number | null
}


export type AggregateStudent = {
  count: number
  avg: StudentAvgAggregateOutputType | null
  sum: StudentSumAggregateOutputType | null
  min: StudentMinAggregateOutputType | null
  max: StudentMaxAggregateOutputType | null
}

export type StudentAvgAggregateOutputType = {
  id: number
  studentID: number
  creditsCompleted: number
  financeId: number | null
  advisorId: number | null
}

export type StudentSumAggregateOutputType = {
  id: number
  studentID: number
  creditsCompleted: number
  financeId: number | null
  advisorId: number | null
}

export type StudentMinAggregateOutputType = {
  id: number
  studentID: number
  creditsCompleted: number
  financeId: number | null
  advisorId: number | null
}

export type StudentMaxAggregateOutputType = {
  id: number
  studentID: number
  creditsCompleted: number
  financeId: number | null
  advisorId: number | null
}


export type StudentAvgAggregateInputType = {
  id?: true
  studentID?: true
  creditsCompleted?: true
  financeId?: true
  advisorId?: true
}

export type StudentSumAggregateInputType = {
  id?: true
  studentID?: true
  creditsCompleted?: true
  financeId?: true
  advisorId?: true
}

export type StudentMinAggregateInputType = {
  id?: true
  studentID?: true
  creditsCompleted?: true
  financeId?: true
  advisorId?: true
}

export type StudentMaxAggregateInputType = {
  id?: true
  studentID?: true
  creditsCompleted?: true
  financeId?: true
  advisorId?: true
}

export type AggregateStudentArgs = {
  where?: StudentWhereInput
  orderBy?: Enumerable<StudentOrderByInput> | StudentOrderByInput
  cursor?: StudentWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<StudentDistinctFieldEnum>
  count?: true
  avg?: StudentAvgAggregateInputType
  sum?: StudentSumAggregateInputType
  min?: StudentMinAggregateInputType
  max?: StudentMaxAggregateInputType
}

export type GetStudentAggregateType<T extends AggregateStudentArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetStudentAggregateScalarType<T[P]>
}

export type GetStudentAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof StudentAvgAggregateOutputType ? StudentAvgAggregateOutputType[P] : never
}
    
    

export type StudentSelect = {
  id?: boolean
  studentID?: boolean
  profilePicURL?: boolean
  creditsCompleted?: boolean
  gender?: boolean
  dob?: boolean
  birthCountry?: boolean
  birthState?: boolean
  maritialStatus?: boolean
  militaryStatus?: boolean
  citizenshipStatus?: boolean
  citizenshipCountry?: boolean
  visaType?: boolean
  visaPermit?: boolean
  visaCountry?: boolean
  names?: boolean | FindManyNameArgs
  addresses?: boolean | FindManyAddressArgs
  phonenumbers?: boolean | FindManyPhoneNumberArgs
  emails?: boolean | FindManyEmailAddressArgs
  contacts?: boolean | FindManyContactArgs
  finance?: boolean | FinanceArgs
  financeId?: boolean
  actionItems?: boolean | FindManyActionItemArgs
  advisor?: boolean | TeacherArgs
  advisorId?: boolean
  classes?: boolean | FindManyClassArgs
}

export type StudentInclude = {
  names?: boolean | FindManyNameArgs
  addresses?: boolean | FindManyAddressArgs
  phonenumbers?: boolean | FindManyPhoneNumberArgs
  emails?: boolean | FindManyEmailAddressArgs
  contacts?: boolean | FindManyContactArgs
  finance?: boolean | FinanceArgs
  actionItems?: boolean | FindManyActionItemArgs
  advisor?: boolean | TeacherArgs
  classes?: boolean | FindManyClassArgs
}

export type StudentGetPayload<
  S extends boolean | null | undefined | StudentArgs,
  U = keyof S
> = S extends true
  ? Student
  : S extends undefined
  ? never
  : S extends StudentArgs | FindManyStudentArgs
  ? 'include' extends U
    ? Student  & {
      [P in TrueKeys<S['include']>]:
      P extends 'names'
      ? Array<NameGetPayload<S['include'][P]>> :
      P extends 'addresses'
      ? Array<AddressGetPayload<S['include'][P]>> :
      P extends 'phonenumbers'
      ? Array<PhoneNumberGetPayload<S['include'][P]>> :
      P extends 'emails'
      ? Array<EmailAddressGetPayload<S['include'][P]>> :
      P extends 'contacts'
      ? Array<ContactGetPayload<S['include'][P]>> :
      P extends 'finance'
      ? FinanceGetPayload<S['include'][P]> | null :
      P extends 'actionItems'
      ? Array<ActionItemGetPayload<S['include'][P]>> :
      P extends 'advisor'
      ? TeacherGetPayload<S['include'][P]> | null :
      P extends 'classes'
      ? Array<ClassGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Student ? Student[P]
: 
      P extends 'names'
      ? Array<NameGetPayload<S['select'][P]>> :
      P extends 'addresses'
      ? Array<AddressGetPayload<S['select'][P]>> :
      P extends 'phonenumbers'
      ? Array<PhoneNumberGetPayload<S['select'][P]>> :
      P extends 'emails'
      ? Array<EmailAddressGetPayload<S['select'][P]>> :
      P extends 'contacts'
      ? Array<ContactGetPayload<S['select'][P]>> :
      P extends 'finance'
      ? FinanceGetPayload<S['select'][P]> | null :
      P extends 'actionItems'
      ? Array<ActionItemGetPayload<S['select'][P]>> :
      P extends 'advisor'
      ? TeacherGetPayload<S['select'][P]> | null :
      P extends 'classes'
      ? Array<ClassGetPayload<S['select'][P]>> : never
    }
  : Student
: Student


export interface StudentDelegate {
  /**
   * Find zero or one Student that matches the filter.
   * @param {FindOneStudentArgs} args - Arguments to find a Student
   * @example
   * // Get one Student
   * const student = await prisma.student.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneStudentArgs>(
    args: Subset<T, FindOneStudentArgs>
  ): CheckSelect<T, Prisma__StudentClient<Student | null>, Prisma__StudentClient<StudentGetPayload<T> | null>>
  /**
   * Find the first Student that matches the filter.
   * @param {FindFirstStudentArgs} args - Arguments to find a Student
   * @example
   * // Get one Student
   * const student = await prisma.student.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstStudentArgs>(
    args?: Subset<T, FindFirstStudentArgs>
  ): CheckSelect<T, Prisma__StudentClient<Student | null>, Prisma__StudentClient<StudentGetPayload<T> | null>>
  /**
   * Find zero or more Students that matches the filter.
   * @param {FindManyStudentArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Students
   * const students = await prisma.student.findMany()
   * 
   * // Get first 10 Students
   * const students = await prisma.student.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyStudentArgs>(
    args?: Subset<T, FindManyStudentArgs>
  ): CheckSelect<T, Promise<Array<Student>>, Promise<Array<StudentGetPayload<T>>>>
  /**
   * Create a Student.
   * @param {StudentCreateArgs} args - Arguments to create a Student.
   * @example
   * // Create one Student
   * const Student = await prisma.student.create({
   *   data: {
   *     // ... data to create a Student
   *   }
   * })
   * 
  **/
  create<T extends StudentCreateArgs>(
    args: Subset<T, StudentCreateArgs>
  ): CheckSelect<T, Prisma__StudentClient<Student>, Prisma__StudentClient<StudentGetPayload<T>>>
  /**
   * Delete a Student.
   * @param {StudentDeleteArgs} args - Arguments to delete one Student.
   * @example
   * // Delete one Student
   * const Student = await prisma.student.delete({
   *   where: {
   *     // ... filter to delete one Student
   *   }
   * })
   * 
  **/
  delete<T extends StudentDeleteArgs>(
    args: Subset<T, StudentDeleteArgs>
  ): CheckSelect<T, Prisma__StudentClient<Student>, Prisma__StudentClient<StudentGetPayload<T>>>
  /**
   * Update one Student.
   * @param {StudentUpdateArgs} args - Arguments to update one Student.
   * @example
   * // Update one Student
   * const student = await prisma.student.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends StudentUpdateArgs>(
    args: Subset<T, StudentUpdateArgs>
  ): CheckSelect<T, Prisma__StudentClient<Student>, Prisma__StudentClient<StudentGetPayload<T>>>
  /**
   * Delete zero or more Students.
   * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
   * @example
   * // Delete a few Students
   * const { count } = await prisma.student.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends StudentDeleteManyArgs>(
    args: Subset<T, StudentDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Students.
   * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Students
   * const student = await prisma.student.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends StudentUpdateManyArgs>(
    args: Subset<T, StudentUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Student.
   * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
   * @example
   * // Update or create a Student
   * const student = await prisma.student.upsert({
   *   create: {
   *     // ... data to create a Student
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Student we want to update
   *   }
   * })
  **/
  upsert<T extends StudentUpsertArgs>(
    args: Subset<T, StudentUpsertArgs>
  ): CheckSelect<T, Prisma__StudentClient<Student>, Prisma__StudentClient<StudentGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyStudentArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateStudentArgs>(args: Subset<T, AggregateStudentArgs>): Promise<GetStudentAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Student.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__StudentClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  names<T extends FindManyNameArgs = {}>(args?: Subset<T, FindManyNameArgs>): CheckSelect<T, Promise<Array<Name>>, Promise<Array<NameGetPayload<T>>>>;

  addresses<T extends FindManyAddressArgs = {}>(args?: Subset<T, FindManyAddressArgs>): CheckSelect<T, Promise<Array<Address>>, Promise<Array<AddressGetPayload<T>>>>;

  phonenumbers<T extends FindManyPhoneNumberArgs = {}>(args?: Subset<T, FindManyPhoneNumberArgs>): CheckSelect<T, Promise<Array<PhoneNumber>>, Promise<Array<PhoneNumberGetPayload<T>>>>;

  emails<T extends FindManyEmailAddressArgs = {}>(args?: Subset<T, FindManyEmailAddressArgs>): CheckSelect<T, Promise<Array<EmailAddress>>, Promise<Array<EmailAddressGetPayload<T>>>>;

  contacts<T extends FindManyContactArgs = {}>(args?: Subset<T, FindManyContactArgs>): CheckSelect<T, Promise<Array<Contact>>, Promise<Array<ContactGetPayload<T>>>>;

  finance<T extends FinanceArgs = {}>(args?: Subset<T, FinanceArgs>): CheckSelect<T, Prisma__FinanceClient<Finance | null>, Prisma__FinanceClient<FinanceGetPayload<T> | null>>;

  actionItems<T extends FindManyActionItemArgs = {}>(args?: Subset<T, FindManyActionItemArgs>): CheckSelect<T, Promise<Array<ActionItem>>, Promise<Array<ActionItemGetPayload<T>>>>;

  advisor<T extends TeacherArgs = {}>(args?: Subset<T, TeacherArgs>): CheckSelect<T, Prisma__TeacherClient<Teacher | null>, Prisma__TeacherClient<TeacherGetPayload<T> | null>>;

  classes<T extends FindManyClassArgs = {}>(args?: Subset<T, FindManyClassArgs>): CheckSelect<T, Promise<Array<Class>>, Promise<Array<ClassGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Student findOne
 */
export type FindOneStudentArgs = {
  /**
   * Select specific fields to fetch from the Student
  **/
  select?: StudentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StudentInclude | null
  /**
   * Filter, which Student to fetch.
  **/
  where: StudentWhereUniqueInput
}


/**
 * Student findFirst
 */
export type FindFirstStudentArgs = {
  /**
   * Select specific fields to fetch from the Student
  **/
  select?: StudentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StudentInclude | null
  /**
   * Filter, which Student to fetch.
  **/
  where?: StudentWhereInput
  orderBy?: Enumerable<StudentOrderByInput> | StudentOrderByInput
  cursor?: StudentWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<StudentDistinctFieldEnum>
}


/**
 * Student findMany
 */
export type FindManyStudentArgs = {
  /**
   * Select specific fields to fetch from the Student
  **/
  select?: StudentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StudentInclude | null
  /**
   * Filter, which Students to fetch.
  **/
  where?: StudentWhereInput
  /**
   * Determine the order of the Students to fetch.
  **/
  orderBy?: Enumerable<StudentOrderByInput> | StudentOrderByInput
  /**
   * Sets the position for listing Students.
  **/
  cursor?: StudentWhereUniqueInput
  /**
   * The number of Students to fetch. If negative number, it will take Students before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Students.
  **/
  skip?: number
  distinct?: Enumerable<StudentDistinctFieldEnum>
}


/**
 * Student create
 */
export type StudentCreateArgs = {
  /**
   * Select specific fields to fetch from the Student
  **/
  select?: StudentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StudentInclude | null
  /**
   * The data needed to create a Student.
  **/
  data: StudentCreateInput
}


/**
 * Student update
 */
export type StudentUpdateArgs = {
  /**
   * Select specific fields to fetch from the Student
  **/
  select?: StudentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StudentInclude | null
  /**
   * The data needed to update a Student.
  **/
  data: StudentUpdateInput
  /**
   * Choose, which Student to update.
  **/
  where: StudentWhereUniqueInput
}


/**
 * Student updateMany
 */
export type StudentUpdateManyArgs = {
  data: StudentUpdateManyMutationInput
  where?: StudentWhereInput
}


/**
 * Student upsert
 */
export type StudentUpsertArgs = {
  /**
   * Select specific fields to fetch from the Student
  **/
  select?: StudentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StudentInclude | null
  /**
   * The filter to search for the Student to update in case it exists.
  **/
  where: StudentWhereUniqueInput
  /**
   * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
  **/
  create: StudentCreateInput
  /**
   * In case the Student was found with the provided `where` argument, update it with this data.
  **/
  update: StudentUpdateInput
}


/**
 * Student delete
 */
export type StudentDeleteArgs = {
  /**
   * Select specific fields to fetch from the Student
  **/
  select?: StudentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StudentInclude | null
  /**
   * Filter which Student to delete.
  **/
  where: StudentWhereUniqueInput
}


/**
 * Student deleteMany
 */
export type StudentDeleteManyArgs = {
  where?: StudentWhereInput
}


/**
 * Student without action
 */
export type StudentArgs = {
  /**
   * Select specific fields to fetch from the Student
  **/
  select?: StudentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: StudentInclude | null
}



/**
 * Model Name
 */

export type Name = {
  id: number
  name: string
  type: string
  studentId: number | null
}


export type AggregateName = {
  count: number
  avg: NameAvgAggregateOutputType | null
  sum: NameSumAggregateOutputType | null
  min: NameMinAggregateOutputType | null
  max: NameMaxAggregateOutputType | null
}

export type NameAvgAggregateOutputType = {
  id: number
  studentId: number | null
}

export type NameSumAggregateOutputType = {
  id: number
  studentId: number | null
}

export type NameMinAggregateOutputType = {
  id: number
  studentId: number | null
}

export type NameMaxAggregateOutputType = {
  id: number
  studentId: number | null
}


export type NameAvgAggregateInputType = {
  id?: true
  studentId?: true
}

export type NameSumAggregateInputType = {
  id?: true
  studentId?: true
}

export type NameMinAggregateInputType = {
  id?: true
  studentId?: true
}

export type NameMaxAggregateInputType = {
  id?: true
  studentId?: true
}

export type AggregateNameArgs = {
  where?: NameWhereInput
  orderBy?: Enumerable<NameOrderByInput> | NameOrderByInput
  cursor?: NameWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<NameDistinctFieldEnum>
  count?: true
  avg?: NameAvgAggregateInputType
  sum?: NameSumAggregateInputType
  min?: NameMinAggregateInputType
  max?: NameMaxAggregateInputType
}

export type GetNameAggregateType<T extends AggregateNameArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetNameAggregateScalarType<T[P]>
}

export type GetNameAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof NameAvgAggregateOutputType ? NameAvgAggregateOutputType[P] : never
}
    
    

export type NameSelect = {
  id?: boolean
  name?: boolean
  type?: boolean
  Student?: boolean | StudentArgs
  studentId?: boolean
}

export type NameInclude = {
  Student?: boolean | StudentArgs
}

export type NameGetPayload<
  S extends boolean | null | undefined | NameArgs,
  U = keyof S
> = S extends true
  ? Name
  : S extends undefined
  ? never
  : S extends NameArgs | FindManyNameArgs
  ? 'include' extends U
    ? Name  & {
      [P in TrueKeys<S['include']>]:
      P extends 'Student'
      ? StudentGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Name ? Name[P]
: 
      P extends 'Student'
      ? StudentGetPayload<S['select'][P]> | null : never
    }
  : Name
: Name


export interface NameDelegate {
  /**
   * Find zero or one Name that matches the filter.
   * @param {FindOneNameArgs} args - Arguments to find a Name
   * @example
   * // Get one Name
   * const name = await prisma.name.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneNameArgs>(
    args: Subset<T, FindOneNameArgs>
  ): CheckSelect<T, Prisma__NameClient<Name | null>, Prisma__NameClient<NameGetPayload<T> | null>>
  /**
   * Find the first Name that matches the filter.
   * @param {FindFirstNameArgs} args - Arguments to find a Name
   * @example
   * // Get one Name
   * const name = await prisma.name.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstNameArgs>(
    args?: Subset<T, FindFirstNameArgs>
  ): CheckSelect<T, Prisma__NameClient<Name | null>, Prisma__NameClient<NameGetPayload<T> | null>>
  /**
   * Find zero or more Names that matches the filter.
   * @param {FindManyNameArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Names
   * const names = await prisma.name.findMany()
   * 
   * // Get first 10 Names
   * const names = await prisma.name.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const nameWithIdOnly = await prisma.name.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyNameArgs>(
    args?: Subset<T, FindManyNameArgs>
  ): CheckSelect<T, Promise<Array<Name>>, Promise<Array<NameGetPayload<T>>>>
  /**
   * Create a Name.
   * @param {NameCreateArgs} args - Arguments to create a Name.
   * @example
   * // Create one Name
   * const Name = await prisma.name.create({
   *   data: {
   *     // ... data to create a Name
   *   }
   * })
   * 
  **/
  create<T extends NameCreateArgs>(
    args: Subset<T, NameCreateArgs>
  ): CheckSelect<T, Prisma__NameClient<Name>, Prisma__NameClient<NameGetPayload<T>>>
  /**
   * Delete a Name.
   * @param {NameDeleteArgs} args - Arguments to delete one Name.
   * @example
   * // Delete one Name
   * const Name = await prisma.name.delete({
   *   where: {
   *     // ... filter to delete one Name
   *   }
   * })
   * 
  **/
  delete<T extends NameDeleteArgs>(
    args: Subset<T, NameDeleteArgs>
  ): CheckSelect<T, Prisma__NameClient<Name>, Prisma__NameClient<NameGetPayload<T>>>
  /**
   * Update one Name.
   * @param {NameUpdateArgs} args - Arguments to update one Name.
   * @example
   * // Update one Name
   * const name = await prisma.name.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends NameUpdateArgs>(
    args: Subset<T, NameUpdateArgs>
  ): CheckSelect<T, Prisma__NameClient<Name>, Prisma__NameClient<NameGetPayload<T>>>
  /**
   * Delete zero or more Names.
   * @param {NameDeleteManyArgs} args - Arguments to filter Names to delete.
   * @example
   * // Delete a few Names
   * const { count } = await prisma.name.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends NameDeleteManyArgs>(
    args: Subset<T, NameDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Names.
   * @param {NameUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Names
   * const name = await prisma.name.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends NameUpdateManyArgs>(
    args: Subset<T, NameUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Name.
   * @param {NameUpsertArgs} args - Arguments to update or create a Name.
   * @example
   * // Update or create a Name
   * const name = await prisma.name.upsert({
   *   create: {
   *     // ... data to create a Name
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Name we want to update
   *   }
   * })
  **/
  upsert<T extends NameUpsertArgs>(
    args: Subset<T, NameUpsertArgs>
  ): CheckSelect<T, Prisma__NameClient<Name>, Prisma__NameClient<NameGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyNameArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateNameArgs>(args: Subset<T, AggregateNameArgs>): Promise<GetNameAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Name.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__NameClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  Student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null>, Prisma__StudentClient<StudentGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Name findOne
 */
export type FindOneNameArgs = {
  /**
   * Select specific fields to fetch from the Name
  **/
  select?: NameSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NameInclude | null
  /**
   * Filter, which Name to fetch.
  **/
  where: NameWhereUniqueInput
}


/**
 * Name findFirst
 */
export type FindFirstNameArgs = {
  /**
   * Select specific fields to fetch from the Name
  **/
  select?: NameSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NameInclude | null
  /**
   * Filter, which Name to fetch.
  **/
  where?: NameWhereInput
  orderBy?: Enumerable<NameOrderByInput> | NameOrderByInput
  cursor?: NameWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<NameDistinctFieldEnum>
}


/**
 * Name findMany
 */
export type FindManyNameArgs = {
  /**
   * Select specific fields to fetch from the Name
  **/
  select?: NameSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NameInclude | null
  /**
   * Filter, which Names to fetch.
  **/
  where?: NameWhereInput
  /**
   * Determine the order of the Names to fetch.
  **/
  orderBy?: Enumerable<NameOrderByInput> | NameOrderByInput
  /**
   * Sets the position for listing Names.
  **/
  cursor?: NameWhereUniqueInput
  /**
   * The number of Names to fetch. If negative number, it will take Names before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Names.
  **/
  skip?: number
  distinct?: Enumerable<NameDistinctFieldEnum>
}


/**
 * Name create
 */
export type NameCreateArgs = {
  /**
   * Select specific fields to fetch from the Name
  **/
  select?: NameSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NameInclude | null
  /**
   * The data needed to create a Name.
  **/
  data: NameCreateInput
}


/**
 * Name update
 */
export type NameUpdateArgs = {
  /**
   * Select specific fields to fetch from the Name
  **/
  select?: NameSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NameInclude | null
  /**
   * The data needed to update a Name.
  **/
  data: NameUpdateInput
  /**
   * Choose, which Name to update.
  **/
  where: NameWhereUniqueInput
}


/**
 * Name updateMany
 */
export type NameUpdateManyArgs = {
  data: NameUpdateManyMutationInput
  where?: NameWhereInput
}


/**
 * Name upsert
 */
export type NameUpsertArgs = {
  /**
   * Select specific fields to fetch from the Name
  **/
  select?: NameSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NameInclude | null
  /**
   * The filter to search for the Name to update in case it exists.
  **/
  where: NameWhereUniqueInput
  /**
   * In case the Name found by the `where` argument doesn't exist, create a new Name with this data.
  **/
  create: NameCreateInput
  /**
   * In case the Name was found with the provided `where` argument, update it with this data.
  **/
  update: NameUpdateInput
}


/**
 * Name delete
 */
export type NameDeleteArgs = {
  /**
   * Select specific fields to fetch from the Name
  **/
  select?: NameSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NameInclude | null
  /**
   * Filter which Name to delete.
  **/
  where: NameWhereUniqueInput
}


/**
 * Name deleteMany
 */
export type NameDeleteManyArgs = {
  where?: NameWhereInput
}


/**
 * Name without action
 */
export type NameArgs = {
  /**
   * Select specific fields to fetch from the Name
  **/
  select?: NameSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NameInclude | null
}



/**
 * Model Address
 */

export type Address = {
  id: number
  type: string
  address: string
  studentId: number | null
}


export type AggregateAddress = {
  count: number
  avg: AddressAvgAggregateOutputType | null
  sum: AddressSumAggregateOutputType | null
  min: AddressMinAggregateOutputType | null
  max: AddressMaxAggregateOutputType | null
}

export type AddressAvgAggregateOutputType = {
  id: number
  studentId: number | null
}

export type AddressSumAggregateOutputType = {
  id: number
  studentId: number | null
}

export type AddressMinAggregateOutputType = {
  id: number
  studentId: number | null
}

export type AddressMaxAggregateOutputType = {
  id: number
  studentId: number | null
}


export type AddressAvgAggregateInputType = {
  id?: true
  studentId?: true
}

export type AddressSumAggregateInputType = {
  id?: true
  studentId?: true
}

export type AddressMinAggregateInputType = {
  id?: true
  studentId?: true
}

export type AddressMaxAggregateInputType = {
  id?: true
  studentId?: true
}

export type AggregateAddressArgs = {
  where?: AddressWhereInput
  orderBy?: Enumerable<AddressOrderByInput> | AddressOrderByInput
  cursor?: AddressWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<AddressDistinctFieldEnum>
  count?: true
  avg?: AddressAvgAggregateInputType
  sum?: AddressSumAggregateInputType
  min?: AddressMinAggregateInputType
  max?: AddressMaxAggregateInputType
}

export type GetAddressAggregateType<T extends AggregateAddressArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetAddressAggregateScalarType<T[P]>
}

export type GetAddressAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof AddressAvgAggregateOutputType ? AddressAvgAggregateOutputType[P] : never
}
    
    

export type AddressSelect = {
  id?: boolean
  type?: boolean
  address?: boolean
  Student?: boolean | StudentArgs
  studentId?: boolean
}

export type AddressInclude = {
  Student?: boolean | StudentArgs
}

export type AddressGetPayload<
  S extends boolean | null | undefined | AddressArgs,
  U = keyof S
> = S extends true
  ? Address
  : S extends undefined
  ? never
  : S extends AddressArgs | FindManyAddressArgs
  ? 'include' extends U
    ? Address  & {
      [P in TrueKeys<S['include']>]:
      P extends 'Student'
      ? StudentGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Address ? Address[P]
: 
      P extends 'Student'
      ? StudentGetPayload<S['select'][P]> | null : never
    }
  : Address
: Address


export interface AddressDelegate {
  /**
   * Find zero or one Address that matches the filter.
   * @param {FindOneAddressArgs} args - Arguments to find a Address
   * @example
   * // Get one Address
   * const address = await prisma.address.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneAddressArgs>(
    args: Subset<T, FindOneAddressArgs>
  ): CheckSelect<T, Prisma__AddressClient<Address | null>, Prisma__AddressClient<AddressGetPayload<T> | null>>
  /**
   * Find the first Address that matches the filter.
   * @param {FindFirstAddressArgs} args - Arguments to find a Address
   * @example
   * // Get one Address
   * const address = await prisma.address.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstAddressArgs>(
    args?: Subset<T, FindFirstAddressArgs>
  ): CheckSelect<T, Prisma__AddressClient<Address | null>, Prisma__AddressClient<AddressGetPayload<T> | null>>
  /**
   * Find zero or more Addresses that matches the filter.
   * @param {FindManyAddressArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Addresses
   * const addresses = await prisma.address.findMany()
   * 
   * // Get first 10 Addresses
   * const addresses = await prisma.address.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyAddressArgs>(
    args?: Subset<T, FindManyAddressArgs>
  ): CheckSelect<T, Promise<Array<Address>>, Promise<Array<AddressGetPayload<T>>>>
  /**
   * Create a Address.
   * @param {AddressCreateArgs} args - Arguments to create a Address.
   * @example
   * // Create one Address
   * const Address = await prisma.address.create({
   *   data: {
   *     // ... data to create a Address
   *   }
   * })
   * 
  **/
  create<T extends AddressCreateArgs>(
    args: Subset<T, AddressCreateArgs>
  ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>
  /**
   * Delete a Address.
   * @param {AddressDeleteArgs} args - Arguments to delete one Address.
   * @example
   * // Delete one Address
   * const Address = await prisma.address.delete({
   *   where: {
   *     // ... filter to delete one Address
   *   }
   * })
   * 
  **/
  delete<T extends AddressDeleteArgs>(
    args: Subset<T, AddressDeleteArgs>
  ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>
  /**
   * Update one Address.
   * @param {AddressUpdateArgs} args - Arguments to update one Address.
   * @example
   * // Update one Address
   * const address = await prisma.address.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends AddressUpdateArgs>(
    args: Subset<T, AddressUpdateArgs>
  ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>
  /**
   * Delete zero or more Addresses.
   * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
   * @example
   * // Delete a few Addresses
   * const { count } = await prisma.address.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends AddressDeleteManyArgs>(
    args: Subset<T, AddressDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Addresses.
   * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Addresses
   * const address = await prisma.address.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends AddressUpdateManyArgs>(
    args: Subset<T, AddressUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Address.
   * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
   * @example
   * // Update or create a Address
   * const address = await prisma.address.upsert({
   *   create: {
   *     // ... data to create a Address
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Address we want to update
   *   }
   * })
  **/
  upsert<T extends AddressUpsertArgs>(
    args: Subset<T, AddressUpsertArgs>
  ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyAddressArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateAddressArgs>(args: Subset<T, AggregateAddressArgs>): Promise<GetAddressAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Address.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__AddressClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  Student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null>, Prisma__StudentClient<StudentGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Address findOne
 */
export type FindOneAddressArgs = {
  /**
   * Select specific fields to fetch from the Address
  **/
  select?: AddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AddressInclude | null
  /**
   * Filter, which Address to fetch.
  **/
  where: AddressWhereUniqueInput
}


/**
 * Address findFirst
 */
export type FindFirstAddressArgs = {
  /**
   * Select specific fields to fetch from the Address
  **/
  select?: AddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AddressInclude | null
  /**
   * Filter, which Address to fetch.
  **/
  where?: AddressWhereInput
  orderBy?: Enumerable<AddressOrderByInput> | AddressOrderByInput
  cursor?: AddressWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<AddressDistinctFieldEnum>
}


/**
 * Address findMany
 */
export type FindManyAddressArgs = {
  /**
   * Select specific fields to fetch from the Address
  **/
  select?: AddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AddressInclude | null
  /**
   * Filter, which Addresses to fetch.
  **/
  where?: AddressWhereInput
  /**
   * Determine the order of the Addresses to fetch.
  **/
  orderBy?: Enumerable<AddressOrderByInput> | AddressOrderByInput
  /**
   * Sets the position for listing Addresses.
  **/
  cursor?: AddressWhereUniqueInput
  /**
   * The number of Addresses to fetch. If negative number, it will take Addresses before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Addresses.
  **/
  skip?: number
  distinct?: Enumerable<AddressDistinctFieldEnum>
}


/**
 * Address create
 */
export type AddressCreateArgs = {
  /**
   * Select specific fields to fetch from the Address
  **/
  select?: AddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AddressInclude | null
  /**
   * The data needed to create a Address.
  **/
  data: AddressCreateInput
}


/**
 * Address update
 */
export type AddressUpdateArgs = {
  /**
   * Select specific fields to fetch from the Address
  **/
  select?: AddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AddressInclude | null
  /**
   * The data needed to update a Address.
  **/
  data: AddressUpdateInput
  /**
   * Choose, which Address to update.
  **/
  where: AddressWhereUniqueInput
}


/**
 * Address updateMany
 */
export type AddressUpdateManyArgs = {
  data: AddressUpdateManyMutationInput
  where?: AddressWhereInput
}


/**
 * Address upsert
 */
export type AddressUpsertArgs = {
  /**
   * Select specific fields to fetch from the Address
  **/
  select?: AddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AddressInclude | null
  /**
   * The filter to search for the Address to update in case it exists.
  **/
  where: AddressWhereUniqueInput
  /**
   * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
  **/
  create: AddressCreateInput
  /**
   * In case the Address was found with the provided `where` argument, update it with this data.
  **/
  update: AddressUpdateInput
}


/**
 * Address delete
 */
export type AddressDeleteArgs = {
  /**
   * Select specific fields to fetch from the Address
  **/
  select?: AddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AddressInclude | null
  /**
   * Filter which Address to delete.
  **/
  where: AddressWhereUniqueInput
}


/**
 * Address deleteMany
 */
export type AddressDeleteManyArgs = {
  where?: AddressWhereInput
}


/**
 * Address without action
 */
export type AddressArgs = {
  /**
   * Select specific fields to fetch from the Address
  **/
  select?: AddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AddressInclude | null
}



/**
 * Model PhoneNumber
 */

export type PhoneNumber = {
  id: number
  type: string
  number: string
  ext: string
  country: number
  preferred: boolean
  studentId: number | null
}


export type AggregatePhoneNumber = {
  count: number
  avg: PhoneNumberAvgAggregateOutputType | null
  sum: PhoneNumberSumAggregateOutputType | null
  min: PhoneNumberMinAggregateOutputType | null
  max: PhoneNumberMaxAggregateOutputType | null
}

export type PhoneNumberAvgAggregateOutputType = {
  id: number
  country: number
  studentId: number | null
}

export type PhoneNumberSumAggregateOutputType = {
  id: number
  country: number
  studentId: number | null
}

export type PhoneNumberMinAggregateOutputType = {
  id: number
  country: number
  studentId: number | null
}

export type PhoneNumberMaxAggregateOutputType = {
  id: number
  country: number
  studentId: number | null
}


export type PhoneNumberAvgAggregateInputType = {
  id?: true
  country?: true
  studentId?: true
}

export type PhoneNumberSumAggregateInputType = {
  id?: true
  country?: true
  studentId?: true
}

export type PhoneNumberMinAggregateInputType = {
  id?: true
  country?: true
  studentId?: true
}

export type PhoneNumberMaxAggregateInputType = {
  id?: true
  country?: true
  studentId?: true
}

export type AggregatePhoneNumberArgs = {
  where?: PhoneNumberWhereInput
  orderBy?: Enumerable<PhoneNumberOrderByInput> | PhoneNumberOrderByInput
  cursor?: PhoneNumberWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<PhoneNumberDistinctFieldEnum>
  count?: true
  avg?: PhoneNumberAvgAggregateInputType
  sum?: PhoneNumberSumAggregateInputType
  min?: PhoneNumberMinAggregateInputType
  max?: PhoneNumberMaxAggregateInputType
}

export type GetPhoneNumberAggregateType<T extends AggregatePhoneNumberArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetPhoneNumberAggregateScalarType<T[P]>
}

export type GetPhoneNumberAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof PhoneNumberAvgAggregateOutputType ? PhoneNumberAvgAggregateOutputType[P] : never
}
    
    

export type PhoneNumberSelect = {
  id?: boolean
  type?: boolean
  number?: boolean
  ext?: boolean
  country?: boolean
  preferred?: boolean
  Student?: boolean | StudentArgs
  studentId?: boolean
}

export type PhoneNumberInclude = {
  Student?: boolean | StudentArgs
}

export type PhoneNumberGetPayload<
  S extends boolean | null | undefined | PhoneNumberArgs,
  U = keyof S
> = S extends true
  ? PhoneNumber
  : S extends undefined
  ? never
  : S extends PhoneNumberArgs | FindManyPhoneNumberArgs
  ? 'include' extends U
    ? PhoneNumber  & {
      [P in TrueKeys<S['include']>]:
      P extends 'Student'
      ? StudentGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof PhoneNumber ? PhoneNumber[P]
: 
      P extends 'Student'
      ? StudentGetPayload<S['select'][P]> | null : never
    }
  : PhoneNumber
: PhoneNumber


export interface PhoneNumberDelegate {
  /**
   * Find zero or one PhoneNumber that matches the filter.
   * @param {FindOnePhoneNumberArgs} args - Arguments to find a PhoneNumber
   * @example
   * // Get one PhoneNumber
   * const phoneNumber = await prisma.phoneNumber.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnePhoneNumberArgs>(
    args: Subset<T, FindOnePhoneNumberArgs>
  ): CheckSelect<T, Prisma__PhoneNumberClient<PhoneNumber | null>, Prisma__PhoneNumberClient<PhoneNumberGetPayload<T> | null>>
  /**
   * Find the first PhoneNumber that matches the filter.
   * @param {FindFirstPhoneNumberArgs} args - Arguments to find a PhoneNumber
   * @example
   * // Get one PhoneNumber
   * const phoneNumber = await prisma.phoneNumber.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstPhoneNumberArgs>(
    args?: Subset<T, FindFirstPhoneNumberArgs>
  ): CheckSelect<T, Prisma__PhoneNumberClient<PhoneNumber | null>, Prisma__PhoneNumberClient<PhoneNumberGetPayload<T> | null>>
  /**
   * Find zero or more PhoneNumbers that matches the filter.
   * @param {FindManyPhoneNumberArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all PhoneNumbers
   * const phoneNumbers = await prisma.phoneNumber.findMany()
   * 
   * // Get first 10 PhoneNumbers
   * const phoneNumbers = await prisma.phoneNumber.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const phoneNumberWithIdOnly = await prisma.phoneNumber.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyPhoneNumberArgs>(
    args?: Subset<T, FindManyPhoneNumberArgs>
  ): CheckSelect<T, Promise<Array<PhoneNumber>>, Promise<Array<PhoneNumberGetPayload<T>>>>
  /**
   * Create a PhoneNumber.
   * @param {PhoneNumberCreateArgs} args - Arguments to create a PhoneNumber.
   * @example
   * // Create one PhoneNumber
   * const PhoneNumber = await prisma.phoneNumber.create({
   *   data: {
   *     // ... data to create a PhoneNumber
   *   }
   * })
   * 
  **/
  create<T extends PhoneNumberCreateArgs>(
    args: Subset<T, PhoneNumberCreateArgs>
  ): CheckSelect<T, Prisma__PhoneNumberClient<PhoneNumber>, Prisma__PhoneNumberClient<PhoneNumberGetPayload<T>>>
  /**
   * Delete a PhoneNumber.
   * @param {PhoneNumberDeleteArgs} args - Arguments to delete one PhoneNumber.
   * @example
   * // Delete one PhoneNumber
   * const PhoneNumber = await prisma.phoneNumber.delete({
   *   where: {
   *     // ... filter to delete one PhoneNumber
   *   }
   * })
   * 
  **/
  delete<T extends PhoneNumberDeleteArgs>(
    args: Subset<T, PhoneNumberDeleteArgs>
  ): CheckSelect<T, Prisma__PhoneNumberClient<PhoneNumber>, Prisma__PhoneNumberClient<PhoneNumberGetPayload<T>>>
  /**
   * Update one PhoneNumber.
   * @param {PhoneNumberUpdateArgs} args - Arguments to update one PhoneNumber.
   * @example
   * // Update one PhoneNumber
   * const phoneNumber = await prisma.phoneNumber.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends PhoneNumberUpdateArgs>(
    args: Subset<T, PhoneNumberUpdateArgs>
  ): CheckSelect<T, Prisma__PhoneNumberClient<PhoneNumber>, Prisma__PhoneNumberClient<PhoneNumberGetPayload<T>>>
  /**
   * Delete zero or more PhoneNumbers.
   * @param {PhoneNumberDeleteManyArgs} args - Arguments to filter PhoneNumbers to delete.
   * @example
   * // Delete a few PhoneNumbers
   * const { count } = await prisma.phoneNumber.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends PhoneNumberDeleteManyArgs>(
    args: Subset<T, PhoneNumberDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more PhoneNumbers.
   * @param {PhoneNumberUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many PhoneNumbers
   * const phoneNumber = await prisma.phoneNumber.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends PhoneNumberUpdateManyArgs>(
    args: Subset<T, PhoneNumberUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one PhoneNumber.
   * @param {PhoneNumberUpsertArgs} args - Arguments to update or create a PhoneNumber.
   * @example
   * // Update or create a PhoneNumber
   * const phoneNumber = await prisma.phoneNumber.upsert({
   *   create: {
   *     // ... data to create a PhoneNumber
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the PhoneNumber we want to update
   *   }
   * })
  **/
  upsert<T extends PhoneNumberUpsertArgs>(
    args: Subset<T, PhoneNumberUpsertArgs>
  ): CheckSelect<T, Prisma__PhoneNumberClient<PhoneNumber>, Prisma__PhoneNumberClient<PhoneNumberGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyPhoneNumberArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregatePhoneNumberArgs>(args: Subset<T, AggregatePhoneNumberArgs>): Promise<GetPhoneNumberAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for PhoneNumber.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__PhoneNumberClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  Student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null>, Prisma__StudentClient<StudentGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * PhoneNumber findOne
 */
export type FindOnePhoneNumberArgs = {
  /**
   * Select specific fields to fetch from the PhoneNumber
  **/
  select?: PhoneNumberSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PhoneNumberInclude | null
  /**
   * Filter, which PhoneNumber to fetch.
  **/
  where: PhoneNumberWhereUniqueInput
}


/**
 * PhoneNumber findFirst
 */
export type FindFirstPhoneNumberArgs = {
  /**
   * Select specific fields to fetch from the PhoneNumber
  **/
  select?: PhoneNumberSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PhoneNumberInclude | null
  /**
   * Filter, which PhoneNumber to fetch.
  **/
  where?: PhoneNumberWhereInput
  orderBy?: Enumerable<PhoneNumberOrderByInput> | PhoneNumberOrderByInput
  cursor?: PhoneNumberWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<PhoneNumberDistinctFieldEnum>
}


/**
 * PhoneNumber findMany
 */
export type FindManyPhoneNumberArgs = {
  /**
   * Select specific fields to fetch from the PhoneNumber
  **/
  select?: PhoneNumberSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PhoneNumberInclude | null
  /**
   * Filter, which PhoneNumbers to fetch.
  **/
  where?: PhoneNumberWhereInput
  /**
   * Determine the order of the PhoneNumbers to fetch.
  **/
  orderBy?: Enumerable<PhoneNumberOrderByInput> | PhoneNumberOrderByInput
  /**
   * Sets the position for listing PhoneNumbers.
  **/
  cursor?: PhoneNumberWhereUniqueInput
  /**
   * The number of PhoneNumbers to fetch. If negative number, it will take PhoneNumbers before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` PhoneNumbers.
  **/
  skip?: number
  distinct?: Enumerable<PhoneNumberDistinctFieldEnum>
}


/**
 * PhoneNumber create
 */
export type PhoneNumberCreateArgs = {
  /**
   * Select specific fields to fetch from the PhoneNumber
  **/
  select?: PhoneNumberSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PhoneNumberInclude | null
  /**
   * The data needed to create a PhoneNumber.
  **/
  data: PhoneNumberCreateInput
}


/**
 * PhoneNumber update
 */
export type PhoneNumberUpdateArgs = {
  /**
   * Select specific fields to fetch from the PhoneNumber
  **/
  select?: PhoneNumberSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PhoneNumberInclude | null
  /**
   * The data needed to update a PhoneNumber.
  **/
  data: PhoneNumberUpdateInput
  /**
   * Choose, which PhoneNumber to update.
  **/
  where: PhoneNumberWhereUniqueInput
}


/**
 * PhoneNumber updateMany
 */
export type PhoneNumberUpdateManyArgs = {
  data: PhoneNumberUpdateManyMutationInput
  where?: PhoneNumberWhereInput
}


/**
 * PhoneNumber upsert
 */
export type PhoneNumberUpsertArgs = {
  /**
   * Select specific fields to fetch from the PhoneNumber
  **/
  select?: PhoneNumberSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PhoneNumberInclude | null
  /**
   * The filter to search for the PhoneNumber to update in case it exists.
  **/
  where: PhoneNumberWhereUniqueInput
  /**
   * In case the PhoneNumber found by the `where` argument doesn't exist, create a new PhoneNumber with this data.
  **/
  create: PhoneNumberCreateInput
  /**
   * In case the PhoneNumber was found with the provided `where` argument, update it with this data.
  **/
  update: PhoneNumberUpdateInput
}


/**
 * PhoneNumber delete
 */
export type PhoneNumberDeleteArgs = {
  /**
   * Select specific fields to fetch from the PhoneNumber
  **/
  select?: PhoneNumberSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PhoneNumberInclude | null
  /**
   * Filter which PhoneNumber to delete.
  **/
  where: PhoneNumberWhereUniqueInput
}


/**
 * PhoneNumber deleteMany
 */
export type PhoneNumberDeleteManyArgs = {
  where?: PhoneNumberWhereInput
}


/**
 * PhoneNumber without action
 */
export type PhoneNumberArgs = {
  /**
   * Select specific fields to fetch from the PhoneNumber
  **/
  select?: PhoneNumberSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PhoneNumberInclude | null
}



/**
 * Model EmailAddress
 */

export type EmailAddress = {
  id: number
  type: string
  address: string
  preferred: boolean
  studentId: number | null
}


export type AggregateEmailAddress = {
  count: number
  avg: EmailAddressAvgAggregateOutputType | null
  sum: EmailAddressSumAggregateOutputType | null
  min: EmailAddressMinAggregateOutputType | null
  max: EmailAddressMaxAggregateOutputType | null
}

export type EmailAddressAvgAggregateOutputType = {
  id: number
  studentId: number | null
}

export type EmailAddressSumAggregateOutputType = {
  id: number
  studentId: number | null
}

export type EmailAddressMinAggregateOutputType = {
  id: number
  studentId: number | null
}

export type EmailAddressMaxAggregateOutputType = {
  id: number
  studentId: number | null
}


export type EmailAddressAvgAggregateInputType = {
  id?: true
  studentId?: true
}

export type EmailAddressSumAggregateInputType = {
  id?: true
  studentId?: true
}

export type EmailAddressMinAggregateInputType = {
  id?: true
  studentId?: true
}

export type EmailAddressMaxAggregateInputType = {
  id?: true
  studentId?: true
}

export type AggregateEmailAddressArgs = {
  where?: EmailAddressWhereInput
  orderBy?: Enumerable<EmailAddressOrderByInput> | EmailAddressOrderByInput
  cursor?: EmailAddressWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<EmailAddressDistinctFieldEnum>
  count?: true
  avg?: EmailAddressAvgAggregateInputType
  sum?: EmailAddressSumAggregateInputType
  min?: EmailAddressMinAggregateInputType
  max?: EmailAddressMaxAggregateInputType
}

export type GetEmailAddressAggregateType<T extends AggregateEmailAddressArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetEmailAddressAggregateScalarType<T[P]>
}

export type GetEmailAddressAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof EmailAddressAvgAggregateOutputType ? EmailAddressAvgAggregateOutputType[P] : never
}
    
    

export type EmailAddressSelect = {
  id?: boolean
  type?: boolean
  address?: boolean
  preferred?: boolean
  Student?: boolean | StudentArgs
  studentId?: boolean
}

export type EmailAddressInclude = {
  Student?: boolean | StudentArgs
}

export type EmailAddressGetPayload<
  S extends boolean | null | undefined | EmailAddressArgs,
  U = keyof S
> = S extends true
  ? EmailAddress
  : S extends undefined
  ? never
  : S extends EmailAddressArgs | FindManyEmailAddressArgs
  ? 'include' extends U
    ? EmailAddress  & {
      [P in TrueKeys<S['include']>]:
      P extends 'Student'
      ? StudentGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof EmailAddress ? EmailAddress[P]
: 
      P extends 'Student'
      ? StudentGetPayload<S['select'][P]> | null : never
    }
  : EmailAddress
: EmailAddress


export interface EmailAddressDelegate {
  /**
   * Find zero or one EmailAddress that matches the filter.
   * @param {FindOneEmailAddressArgs} args - Arguments to find a EmailAddress
   * @example
   * // Get one EmailAddress
   * const emailAddress = await prisma.emailAddress.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneEmailAddressArgs>(
    args: Subset<T, FindOneEmailAddressArgs>
  ): CheckSelect<T, Prisma__EmailAddressClient<EmailAddress | null>, Prisma__EmailAddressClient<EmailAddressGetPayload<T> | null>>
  /**
   * Find the first EmailAddress that matches the filter.
   * @param {FindFirstEmailAddressArgs} args - Arguments to find a EmailAddress
   * @example
   * // Get one EmailAddress
   * const emailAddress = await prisma.emailAddress.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstEmailAddressArgs>(
    args?: Subset<T, FindFirstEmailAddressArgs>
  ): CheckSelect<T, Prisma__EmailAddressClient<EmailAddress | null>, Prisma__EmailAddressClient<EmailAddressGetPayload<T> | null>>
  /**
   * Find zero or more EmailAddresses that matches the filter.
   * @param {FindManyEmailAddressArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all EmailAddresses
   * const emailAddresses = await prisma.emailAddress.findMany()
   * 
   * // Get first 10 EmailAddresses
   * const emailAddresses = await prisma.emailAddress.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const emailAddressWithIdOnly = await prisma.emailAddress.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyEmailAddressArgs>(
    args?: Subset<T, FindManyEmailAddressArgs>
  ): CheckSelect<T, Promise<Array<EmailAddress>>, Promise<Array<EmailAddressGetPayload<T>>>>
  /**
   * Create a EmailAddress.
   * @param {EmailAddressCreateArgs} args - Arguments to create a EmailAddress.
   * @example
   * // Create one EmailAddress
   * const EmailAddress = await prisma.emailAddress.create({
   *   data: {
   *     // ... data to create a EmailAddress
   *   }
   * })
   * 
  **/
  create<T extends EmailAddressCreateArgs>(
    args: Subset<T, EmailAddressCreateArgs>
  ): CheckSelect<T, Prisma__EmailAddressClient<EmailAddress>, Prisma__EmailAddressClient<EmailAddressGetPayload<T>>>
  /**
   * Delete a EmailAddress.
   * @param {EmailAddressDeleteArgs} args - Arguments to delete one EmailAddress.
   * @example
   * // Delete one EmailAddress
   * const EmailAddress = await prisma.emailAddress.delete({
   *   where: {
   *     // ... filter to delete one EmailAddress
   *   }
   * })
   * 
  **/
  delete<T extends EmailAddressDeleteArgs>(
    args: Subset<T, EmailAddressDeleteArgs>
  ): CheckSelect<T, Prisma__EmailAddressClient<EmailAddress>, Prisma__EmailAddressClient<EmailAddressGetPayload<T>>>
  /**
   * Update one EmailAddress.
   * @param {EmailAddressUpdateArgs} args - Arguments to update one EmailAddress.
   * @example
   * // Update one EmailAddress
   * const emailAddress = await prisma.emailAddress.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends EmailAddressUpdateArgs>(
    args: Subset<T, EmailAddressUpdateArgs>
  ): CheckSelect<T, Prisma__EmailAddressClient<EmailAddress>, Prisma__EmailAddressClient<EmailAddressGetPayload<T>>>
  /**
   * Delete zero or more EmailAddresses.
   * @param {EmailAddressDeleteManyArgs} args - Arguments to filter EmailAddresses to delete.
   * @example
   * // Delete a few EmailAddresses
   * const { count } = await prisma.emailAddress.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends EmailAddressDeleteManyArgs>(
    args: Subset<T, EmailAddressDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more EmailAddresses.
   * @param {EmailAddressUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many EmailAddresses
   * const emailAddress = await prisma.emailAddress.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends EmailAddressUpdateManyArgs>(
    args: Subset<T, EmailAddressUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one EmailAddress.
   * @param {EmailAddressUpsertArgs} args - Arguments to update or create a EmailAddress.
   * @example
   * // Update or create a EmailAddress
   * const emailAddress = await prisma.emailAddress.upsert({
   *   create: {
   *     // ... data to create a EmailAddress
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the EmailAddress we want to update
   *   }
   * })
  **/
  upsert<T extends EmailAddressUpsertArgs>(
    args: Subset<T, EmailAddressUpsertArgs>
  ): CheckSelect<T, Prisma__EmailAddressClient<EmailAddress>, Prisma__EmailAddressClient<EmailAddressGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyEmailAddressArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateEmailAddressArgs>(args: Subset<T, AggregateEmailAddressArgs>): Promise<GetEmailAddressAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for EmailAddress.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__EmailAddressClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  Student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null>, Prisma__StudentClient<StudentGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * EmailAddress findOne
 */
export type FindOneEmailAddressArgs = {
  /**
   * Select specific fields to fetch from the EmailAddress
  **/
  select?: EmailAddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EmailAddressInclude | null
  /**
   * Filter, which EmailAddress to fetch.
  **/
  where: EmailAddressWhereUniqueInput
}


/**
 * EmailAddress findFirst
 */
export type FindFirstEmailAddressArgs = {
  /**
   * Select specific fields to fetch from the EmailAddress
  **/
  select?: EmailAddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EmailAddressInclude | null
  /**
   * Filter, which EmailAddress to fetch.
  **/
  where?: EmailAddressWhereInput
  orderBy?: Enumerable<EmailAddressOrderByInput> | EmailAddressOrderByInput
  cursor?: EmailAddressWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<EmailAddressDistinctFieldEnum>
}


/**
 * EmailAddress findMany
 */
export type FindManyEmailAddressArgs = {
  /**
   * Select specific fields to fetch from the EmailAddress
  **/
  select?: EmailAddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EmailAddressInclude | null
  /**
   * Filter, which EmailAddresses to fetch.
  **/
  where?: EmailAddressWhereInput
  /**
   * Determine the order of the EmailAddresses to fetch.
  **/
  orderBy?: Enumerable<EmailAddressOrderByInput> | EmailAddressOrderByInput
  /**
   * Sets the position for listing EmailAddresses.
  **/
  cursor?: EmailAddressWhereUniqueInput
  /**
   * The number of EmailAddresses to fetch. If negative number, it will take EmailAddresses before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` EmailAddresses.
  **/
  skip?: number
  distinct?: Enumerable<EmailAddressDistinctFieldEnum>
}


/**
 * EmailAddress create
 */
export type EmailAddressCreateArgs = {
  /**
   * Select specific fields to fetch from the EmailAddress
  **/
  select?: EmailAddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EmailAddressInclude | null
  /**
   * The data needed to create a EmailAddress.
  **/
  data: EmailAddressCreateInput
}


/**
 * EmailAddress update
 */
export type EmailAddressUpdateArgs = {
  /**
   * Select specific fields to fetch from the EmailAddress
  **/
  select?: EmailAddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EmailAddressInclude | null
  /**
   * The data needed to update a EmailAddress.
  **/
  data: EmailAddressUpdateInput
  /**
   * Choose, which EmailAddress to update.
  **/
  where: EmailAddressWhereUniqueInput
}


/**
 * EmailAddress updateMany
 */
export type EmailAddressUpdateManyArgs = {
  data: EmailAddressUpdateManyMutationInput
  where?: EmailAddressWhereInput
}


/**
 * EmailAddress upsert
 */
export type EmailAddressUpsertArgs = {
  /**
   * Select specific fields to fetch from the EmailAddress
  **/
  select?: EmailAddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EmailAddressInclude | null
  /**
   * The filter to search for the EmailAddress to update in case it exists.
  **/
  where: EmailAddressWhereUniqueInput
  /**
   * In case the EmailAddress found by the `where` argument doesn't exist, create a new EmailAddress with this data.
  **/
  create: EmailAddressCreateInput
  /**
   * In case the EmailAddress was found with the provided `where` argument, update it with this data.
  **/
  update: EmailAddressUpdateInput
}


/**
 * EmailAddress delete
 */
export type EmailAddressDeleteArgs = {
  /**
   * Select specific fields to fetch from the EmailAddress
  **/
  select?: EmailAddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EmailAddressInclude | null
  /**
   * Filter which EmailAddress to delete.
  **/
  where: EmailAddressWhereUniqueInput
}


/**
 * EmailAddress deleteMany
 */
export type EmailAddressDeleteManyArgs = {
  where?: EmailAddressWhereInput
}


/**
 * EmailAddress without action
 */
export type EmailAddressArgs = {
  /**
   * Select specific fields to fetch from the EmailAddress
  **/
  select?: EmailAddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: EmailAddressInclude | null
}



/**
 * Model Finance
 */

export type Finance = {
  id: number
  accountBalance: number
}


export type AggregateFinance = {
  count: number
  avg: FinanceAvgAggregateOutputType | null
  sum: FinanceSumAggregateOutputType | null
  min: FinanceMinAggregateOutputType | null
  max: FinanceMaxAggregateOutputType | null
}

export type FinanceAvgAggregateOutputType = {
  id: number
  accountBalance: number
}

export type FinanceSumAggregateOutputType = {
  id: number
  accountBalance: number
}

export type FinanceMinAggregateOutputType = {
  id: number
  accountBalance: number
}

export type FinanceMaxAggregateOutputType = {
  id: number
  accountBalance: number
}


export type FinanceAvgAggregateInputType = {
  id?: true
  accountBalance?: true
}

export type FinanceSumAggregateInputType = {
  id?: true
  accountBalance?: true
}

export type FinanceMinAggregateInputType = {
  id?: true
  accountBalance?: true
}

export type FinanceMaxAggregateInputType = {
  id?: true
  accountBalance?: true
}

export type AggregateFinanceArgs = {
  where?: FinanceWhereInput
  orderBy?: Enumerable<FinanceOrderByInput> | FinanceOrderByInput
  cursor?: FinanceWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<FinanceDistinctFieldEnum>
  count?: true
  avg?: FinanceAvgAggregateInputType
  sum?: FinanceSumAggregateInputType
  min?: FinanceMinAggregateInputType
  max?: FinanceMaxAggregateInputType
}

export type GetFinanceAggregateType<T extends AggregateFinanceArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetFinanceAggregateScalarType<T[P]>
}

export type GetFinanceAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof FinanceAvgAggregateOutputType ? FinanceAvgAggregateOutputType[P] : never
}
    
    

export type FinanceSelect = {
  id?: boolean
  accountBalance?: boolean
  Student?: boolean | FindManyStudentArgs
}

export type FinanceInclude = {
  Student?: boolean | FindManyStudentArgs
}

export type FinanceGetPayload<
  S extends boolean | null | undefined | FinanceArgs,
  U = keyof S
> = S extends true
  ? Finance
  : S extends undefined
  ? never
  : S extends FinanceArgs | FindManyFinanceArgs
  ? 'include' extends U
    ? Finance  & {
      [P in TrueKeys<S['include']>]:
      P extends 'Student'
      ? Array<StudentGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Finance ? Finance[P]
: 
      P extends 'Student'
      ? Array<StudentGetPayload<S['select'][P]>> : never
    }
  : Finance
: Finance


export interface FinanceDelegate {
  /**
   * Find zero or one Finance that matches the filter.
   * @param {FindOneFinanceArgs} args - Arguments to find a Finance
   * @example
   * // Get one Finance
   * const finance = await prisma.finance.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneFinanceArgs>(
    args: Subset<T, FindOneFinanceArgs>
  ): CheckSelect<T, Prisma__FinanceClient<Finance | null>, Prisma__FinanceClient<FinanceGetPayload<T> | null>>
  /**
   * Find the first Finance that matches the filter.
   * @param {FindFirstFinanceArgs} args - Arguments to find a Finance
   * @example
   * // Get one Finance
   * const finance = await prisma.finance.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstFinanceArgs>(
    args?: Subset<T, FindFirstFinanceArgs>
  ): CheckSelect<T, Prisma__FinanceClient<Finance | null>, Prisma__FinanceClient<FinanceGetPayload<T> | null>>
  /**
   * Find zero or more Finances that matches the filter.
   * @param {FindManyFinanceArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Finances
   * const finances = await prisma.finance.findMany()
   * 
   * // Get first 10 Finances
   * const finances = await prisma.finance.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const financeWithIdOnly = await prisma.finance.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyFinanceArgs>(
    args?: Subset<T, FindManyFinanceArgs>
  ): CheckSelect<T, Promise<Array<Finance>>, Promise<Array<FinanceGetPayload<T>>>>
  /**
   * Create a Finance.
   * @param {FinanceCreateArgs} args - Arguments to create a Finance.
   * @example
   * // Create one Finance
   * const Finance = await prisma.finance.create({
   *   data: {
   *     // ... data to create a Finance
   *   }
   * })
   * 
  **/
  create<T extends FinanceCreateArgs>(
    args: Subset<T, FinanceCreateArgs>
  ): CheckSelect<T, Prisma__FinanceClient<Finance>, Prisma__FinanceClient<FinanceGetPayload<T>>>
  /**
   * Delete a Finance.
   * @param {FinanceDeleteArgs} args - Arguments to delete one Finance.
   * @example
   * // Delete one Finance
   * const Finance = await prisma.finance.delete({
   *   where: {
   *     // ... filter to delete one Finance
   *   }
   * })
   * 
  **/
  delete<T extends FinanceDeleteArgs>(
    args: Subset<T, FinanceDeleteArgs>
  ): CheckSelect<T, Prisma__FinanceClient<Finance>, Prisma__FinanceClient<FinanceGetPayload<T>>>
  /**
   * Update one Finance.
   * @param {FinanceUpdateArgs} args - Arguments to update one Finance.
   * @example
   * // Update one Finance
   * const finance = await prisma.finance.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends FinanceUpdateArgs>(
    args: Subset<T, FinanceUpdateArgs>
  ): CheckSelect<T, Prisma__FinanceClient<Finance>, Prisma__FinanceClient<FinanceGetPayload<T>>>
  /**
   * Delete zero or more Finances.
   * @param {FinanceDeleteManyArgs} args - Arguments to filter Finances to delete.
   * @example
   * // Delete a few Finances
   * const { count } = await prisma.finance.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends FinanceDeleteManyArgs>(
    args: Subset<T, FinanceDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Finances.
   * @param {FinanceUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Finances
   * const finance = await prisma.finance.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends FinanceUpdateManyArgs>(
    args: Subset<T, FinanceUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Finance.
   * @param {FinanceUpsertArgs} args - Arguments to update or create a Finance.
   * @example
   * // Update or create a Finance
   * const finance = await prisma.finance.upsert({
   *   create: {
   *     // ... data to create a Finance
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Finance we want to update
   *   }
   * })
  **/
  upsert<T extends FinanceUpsertArgs>(
    args: Subset<T, FinanceUpsertArgs>
  ): CheckSelect<T, Prisma__FinanceClient<Finance>, Prisma__FinanceClient<FinanceGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyFinanceArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateFinanceArgs>(args: Subset<T, AggregateFinanceArgs>): Promise<GetFinanceAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Finance.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__FinanceClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  Student<T extends FindManyStudentArgs = {}>(args?: Subset<T, FindManyStudentArgs>): CheckSelect<T, Promise<Array<Student>>, Promise<Array<StudentGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Finance findOne
 */
export type FindOneFinanceArgs = {
  /**
   * Select specific fields to fetch from the Finance
  **/
  select?: FinanceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FinanceInclude | null
  /**
   * Filter, which Finance to fetch.
  **/
  where: FinanceWhereUniqueInput
}


/**
 * Finance findFirst
 */
export type FindFirstFinanceArgs = {
  /**
   * Select specific fields to fetch from the Finance
  **/
  select?: FinanceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FinanceInclude | null
  /**
   * Filter, which Finance to fetch.
  **/
  where?: FinanceWhereInput
  orderBy?: Enumerable<FinanceOrderByInput> | FinanceOrderByInput
  cursor?: FinanceWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<FinanceDistinctFieldEnum>
}


/**
 * Finance findMany
 */
export type FindManyFinanceArgs = {
  /**
   * Select specific fields to fetch from the Finance
  **/
  select?: FinanceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FinanceInclude | null
  /**
   * Filter, which Finances to fetch.
  **/
  where?: FinanceWhereInput
  /**
   * Determine the order of the Finances to fetch.
  **/
  orderBy?: Enumerable<FinanceOrderByInput> | FinanceOrderByInput
  /**
   * Sets the position for listing Finances.
  **/
  cursor?: FinanceWhereUniqueInput
  /**
   * The number of Finances to fetch. If negative number, it will take Finances before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Finances.
  **/
  skip?: number
  distinct?: Enumerable<FinanceDistinctFieldEnum>
}


/**
 * Finance create
 */
export type FinanceCreateArgs = {
  /**
   * Select specific fields to fetch from the Finance
  **/
  select?: FinanceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FinanceInclude | null
  /**
   * The data needed to create a Finance.
  **/
  data: FinanceCreateInput
}


/**
 * Finance update
 */
export type FinanceUpdateArgs = {
  /**
   * Select specific fields to fetch from the Finance
  **/
  select?: FinanceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FinanceInclude | null
  /**
   * The data needed to update a Finance.
  **/
  data: FinanceUpdateInput
  /**
   * Choose, which Finance to update.
  **/
  where: FinanceWhereUniqueInput
}


/**
 * Finance updateMany
 */
export type FinanceUpdateManyArgs = {
  data: FinanceUpdateManyMutationInput
  where?: FinanceWhereInput
}


/**
 * Finance upsert
 */
export type FinanceUpsertArgs = {
  /**
   * Select specific fields to fetch from the Finance
  **/
  select?: FinanceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FinanceInclude | null
  /**
   * The filter to search for the Finance to update in case it exists.
  **/
  where: FinanceWhereUniqueInput
  /**
   * In case the Finance found by the `where` argument doesn't exist, create a new Finance with this data.
  **/
  create: FinanceCreateInput
  /**
   * In case the Finance was found with the provided `where` argument, update it with this data.
  **/
  update: FinanceUpdateInput
}


/**
 * Finance delete
 */
export type FinanceDeleteArgs = {
  /**
   * Select specific fields to fetch from the Finance
  **/
  select?: FinanceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FinanceInclude | null
  /**
   * Filter which Finance to delete.
  **/
  where: FinanceWhereUniqueInput
}


/**
 * Finance deleteMany
 */
export type FinanceDeleteManyArgs = {
  where?: FinanceWhereInput
}


/**
 * Finance without action
 */
export type FinanceArgs = {
  /**
   * Select specific fields to fetch from the Finance
  **/
  select?: FinanceSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: FinanceInclude | null
}



/**
 * Model Announcement
 */

export type Announcement = {
  id: number
  title: string
  detail: string
  imageUrl: string
}


export type AggregateAnnouncement = {
  count: number
  avg: AnnouncementAvgAggregateOutputType | null
  sum: AnnouncementSumAggregateOutputType | null
  min: AnnouncementMinAggregateOutputType | null
  max: AnnouncementMaxAggregateOutputType | null
}

export type AnnouncementAvgAggregateOutputType = {
  id: number
}

export type AnnouncementSumAggregateOutputType = {
  id: number
}

export type AnnouncementMinAggregateOutputType = {
  id: number
}

export type AnnouncementMaxAggregateOutputType = {
  id: number
}


export type AnnouncementAvgAggregateInputType = {
  id?: true
}

export type AnnouncementSumAggregateInputType = {
  id?: true
}

export type AnnouncementMinAggregateInputType = {
  id?: true
}

export type AnnouncementMaxAggregateInputType = {
  id?: true
}

export type AggregateAnnouncementArgs = {
  where?: AnnouncementWhereInput
  orderBy?: Enumerable<AnnouncementOrderByInput> | AnnouncementOrderByInput
  cursor?: AnnouncementWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<AnnouncementDistinctFieldEnum>
  count?: true
  avg?: AnnouncementAvgAggregateInputType
  sum?: AnnouncementSumAggregateInputType
  min?: AnnouncementMinAggregateInputType
  max?: AnnouncementMaxAggregateInputType
}

export type GetAnnouncementAggregateType<T extends AggregateAnnouncementArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetAnnouncementAggregateScalarType<T[P]>
}

export type GetAnnouncementAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof AnnouncementAvgAggregateOutputType ? AnnouncementAvgAggregateOutputType[P] : never
}
    
    

export type AnnouncementSelect = {
  id?: boolean
  title?: boolean
  detail?: boolean
  imageUrl?: boolean
}

export type AnnouncementGetPayload<
  S extends boolean | null | undefined | AnnouncementArgs,
  U = keyof S
> = S extends true
  ? Announcement
  : S extends undefined
  ? never
  : S extends AnnouncementArgs | FindManyAnnouncementArgs
  ? 'include' extends U
    ? Announcement 
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Announcement ? Announcement[P]
: 
 never
    }
  : Announcement
: Announcement


export interface AnnouncementDelegate {
  /**
   * Find zero or one Announcement that matches the filter.
   * @param {FindOneAnnouncementArgs} args - Arguments to find a Announcement
   * @example
   * // Get one Announcement
   * const announcement = await prisma.announcement.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneAnnouncementArgs>(
    args: Subset<T, FindOneAnnouncementArgs>
  ): CheckSelect<T, Prisma__AnnouncementClient<Announcement | null>, Prisma__AnnouncementClient<AnnouncementGetPayload<T> | null>>
  /**
   * Find the first Announcement that matches the filter.
   * @param {FindFirstAnnouncementArgs} args - Arguments to find a Announcement
   * @example
   * // Get one Announcement
   * const announcement = await prisma.announcement.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstAnnouncementArgs>(
    args?: Subset<T, FindFirstAnnouncementArgs>
  ): CheckSelect<T, Prisma__AnnouncementClient<Announcement | null>, Prisma__AnnouncementClient<AnnouncementGetPayload<T> | null>>
  /**
   * Find zero or more Announcements that matches the filter.
   * @param {FindManyAnnouncementArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Announcements
   * const announcements = await prisma.announcement.findMany()
   * 
   * // Get first 10 Announcements
   * const announcements = await prisma.announcement.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const announcementWithIdOnly = await prisma.announcement.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyAnnouncementArgs>(
    args?: Subset<T, FindManyAnnouncementArgs>
  ): CheckSelect<T, Promise<Array<Announcement>>, Promise<Array<AnnouncementGetPayload<T>>>>
  /**
   * Create a Announcement.
   * @param {AnnouncementCreateArgs} args - Arguments to create a Announcement.
   * @example
   * // Create one Announcement
   * const Announcement = await prisma.announcement.create({
   *   data: {
   *     // ... data to create a Announcement
   *   }
   * })
   * 
  **/
  create<T extends AnnouncementCreateArgs>(
    args: Subset<T, AnnouncementCreateArgs>
  ): CheckSelect<T, Prisma__AnnouncementClient<Announcement>, Prisma__AnnouncementClient<AnnouncementGetPayload<T>>>
  /**
   * Delete a Announcement.
   * @param {AnnouncementDeleteArgs} args - Arguments to delete one Announcement.
   * @example
   * // Delete one Announcement
   * const Announcement = await prisma.announcement.delete({
   *   where: {
   *     // ... filter to delete one Announcement
   *   }
   * })
   * 
  **/
  delete<T extends AnnouncementDeleteArgs>(
    args: Subset<T, AnnouncementDeleteArgs>
  ): CheckSelect<T, Prisma__AnnouncementClient<Announcement>, Prisma__AnnouncementClient<AnnouncementGetPayload<T>>>
  /**
   * Update one Announcement.
   * @param {AnnouncementUpdateArgs} args - Arguments to update one Announcement.
   * @example
   * // Update one Announcement
   * const announcement = await prisma.announcement.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends AnnouncementUpdateArgs>(
    args: Subset<T, AnnouncementUpdateArgs>
  ): CheckSelect<T, Prisma__AnnouncementClient<Announcement>, Prisma__AnnouncementClient<AnnouncementGetPayload<T>>>
  /**
   * Delete zero or more Announcements.
   * @param {AnnouncementDeleteManyArgs} args - Arguments to filter Announcements to delete.
   * @example
   * // Delete a few Announcements
   * const { count } = await prisma.announcement.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends AnnouncementDeleteManyArgs>(
    args: Subset<T, AnnouncementDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Announcements.
   * @param {AnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Announcements
   * const announcement = await prisma.announcement.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends AnnouncementUpdateManyArgs>(
    args: Subset<T, AnnouncementUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Announcement.
   * @param {AnnouncementUpsertArgs} args - Arguments to update or create a Announcement.
   * @example
   * // Update or create a Announcement
   * const announcement = await prisma.announcement.upsert({
   *   create: {
   *     // ... data to create a Announcement
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Announcement we want to update
   *   }
   * })
  **/
  upsert<T extends AnnouncementUpsertArgs>(
    args: Subset<T, AnnouncementUpsertArgs>
  ): CheckSelect<T, Prisma__AnnouncementClient<Announcement>, Prisma__AnnouncementClient<AnnouncementGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyAnnouncementArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateAnnouncementArgs>(args: Subset<T, AggregateAnnouncementArgs>): Promise<GetAnnouncementAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Announcement.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__AnnouncementClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';


  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Announcement findOne
 */
export type FindOneAnnouncementArgs = {
  /**
   * Select specific fields to fetch from the Announcement
  **/
  select?: AnnouncementSelect | null
  /**
   * Filter, which Announcement to fetch.
  **/
  where: AnnouncementWhereUniqueInput
}


/**
 * Announcement findFirst
 */
export type FindFirstAnnouncementArgs = {
  /**
   * Select specific fields to fetch from the Announcement
  **/
  select?: AnnouncementSelect | null
  /**
   * Filter, which Announcement to fetch.
  **/
  where?: AnnouncementWhereInput
  orderBy?: Enumerable<AnnouncementOrderByInput> | AnnouncementOrderByInput
  cursor?: AnnouncementWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<AnnouncementDistinctFieldEnum>
}


/**
 * Announcement findMany
 */
export type FindManyAnnouncementArgs = {
  /**
   * Select specific fields to fetch from the Announcement
  **/
  select?: AnnouncementSelect | null
  /**
   * Filter, which Announcements to fetch.
  **/
  where?: AnnouncementWhereInput
  /**
   * Determine the order of the Announcements to fetch.
  **/
  orderBy?: Enumerable<AnnouncementOrderByInput> | AnnouncementOrderByInput
  /**
   * Sets the position for listing Announcements.
  **/
  cursor?: AnnouncementWhereUniqueInput
  /**
   * The number of Announcements to fetch. If negative number, it will take Announcements before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Announcements.
  **/
  skip?: number
  distinct?: Enumerable<AnnouncementDistinctFieldEnum>
}


/**
 * Announcement create
 */
export type AnnouncementCreateArgs = {
  /**
   * Select specific fields to fetch from the Announcement
  **/
  select?: AnnouncementSelect | null
  /**
   * The data needed to create a Announcement.
  **/
  data: AnnouncementCreateInput
}


/**
 * Announcement update
 */
export type AnnouncementUpdateArgs = {
  /**
   * Select specific fields to fetch from the Announcement
  **/
  select?: AnnouncementSelect | null
  /**
   * The data needed to update a Announcement.
  **/
  data: AnnouncementUpdateInput
  /**
   * Choose, which Announcement to update.
  **/
  where: AnnouncementWhereUniqueInput
}


/**
 * Announcement updateMany
 */
export type AnnouncementUpdateManyArgs = {
  data: AnnouncementUpdateManyMutationInput
  where?: AnnouncementWhereInput
}


/**
 * Announcement upsert
 */
export type AnnouncementUpsertArgs = {
  /**
   * Select specific fields to fetch from the Announcement
  **/
  select?: AnnouncementSelect | null
  /**
   * The filter to search for the Announcement to update in case it exists.
  **/
  where: AnnouncementWhereUniqueInput
  /**
   * In case the Announcement found by the `where` argument doesn't exist, create a new Announcement with this data.
  **/
  create: AnnouncementCreateInput
  /**
   * In case the Announcement was found with the provided `where` argument, update it with this data.
  **/
  update: AnnouncementUpdateInput
}


/**
 * Announcement delete
 */
export type AnnouncementDeleteArgs = {
  /**
   * Select specific fields to fetch from the Announcement
  **/
  select?: AnnouncementSelect | null
  /**
   * Filter which Announcement to delete.
  **/
  where: AnnouncementWhereUniqueInput
}


/**
 * Announcement deleteMany
 */
export type AnnouncementDeleteManyArgs = {
  where?: AnnouncementWhereInput
}


/**
 * Announcement without action
 */
export type AnnouncementArgs = {
  /**
   * Select specific fields to fetch from the Announcement
  **/
  select?: AnnouncementSelect | null
}



/**
 * Model ActionItem
 */

export type ActionItem = {
  id: number
  title: string
  detail: string
  completed: boolean
  studentId: number | null
}


export type AggregateActionItem = {
  count: number
  avg: ActionItemAvgAggregateOutputType | null
  sum: ActionItemSumAggregateOutputType | null
  min: ActionItemMinAggregateOutputType | null
  max: ActionItemMaxAggregateOutputType | null
}

export type ActionItemAvgAggregateOutputType = {
  id: number
  studentId: number | null
}

export type ActionItemSumAggregateOutputType = {
  id: number
  studentId: number | null
}

export type ActionItemMinAggregateOutputType = {
  id: number
  studentId: number | null
}

export type ActionItemMaxAggregateOutputType = {
  id: number
  studentId: number | null
}


export type ActionItemAvgAggregateInputType = {
  id?: true
  studentId?: true
}

export type ActionItemSumAggregateInputType = {
  id?: true
  studentId?: true
}

export type ActionItemMinAggregateInputType = {
  id?: true
  studentId?: true
}

export type ActionItemMaxAggregateInputType = {
  id?: true
  studentId?: true
}

export type AggregateActionItemArgs = {
  where?: ActionItemWhereInput
  orderBy?: Enumerable<ActionItemOrderByInput> | ActionItemOrderByInput
  cursor?: ActionItemWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ActionItemDistinctFieldEnum>
  count?: true
  avg?: ActionItemAvgAggregateInputType
  sum?: ActionItemSumAggregateInputType
  min?: ActionItemMinAggregateInputType
  max?: ActionItemMaxAggregateInputType
}

export type GetActionItemAggregateType<T extends AggregateActionItemArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetActionItemAggregateScalarType<T[P]>
}

export type GetActionItemAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof ActionItemAvgAggregateOutputType ? ActionItemAvgAggregateOutputType[P] : never
}
    
    

export type ActionItemSelect = {
  id?: boolean
  title?: boolean
  detail?: boolean
  completed?: boolean
  Student?: boolean | StudentArgs
  studentId?: boolean
}

export type ActionItemInclude = {
  Student?: boolean | StudentArgs
}

export type ActionItemGetPayload<
  S extends boolean | null | undefined | ActionItemArgs,
  U = keyof S
> = S extends true
  ? ActionItem
  : S extends undefined
  ? never
  : S extends ActionItemArgs | FindManyActionItemArgs
  ? 'include' extends U
    ? ActionItem  & {
      [P in TrueKeys<S['include']>]:
      P extends 'Student'
      ? StudentGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof ActionItem ? ActionItem[P]
: 
      P extends 'Student'
      ? StudentGetPayload<S['select'][P]> | null : never
    }
  : ActionItem
: ActionItem


export interface ActionItemDelegate {
  /**
   * Find zero or one ActionItem that matches the filter.
   * @param {FindOneActionItemArgs} args - Arguments to find a ActionItem
   * @example
   * // Get one ActionItem
   * const actionItem = await prisma.actionItem.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneActionItemArgs>(
    args: Subset<T, FindOneActionItemArgs>
  ): CheckSelect<T, Prisma__ActionItemClient<ActionItem | null>, Prisma__ActionItemClient<ActionItemGetPayload<T> | null>>
  /**
   * Find the first ActionItem that matches the filter.
   * @param {FindFirstActionItemArgs} args - Arguments to find a ActionItem
   * @example
   * // Get one ActionItem
   * const actionItem = await prisma.actionItem.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstActionItemArgs>(
    args?: Subset<T, FindFirstActionItemArgs>
  ): CheckSelect<T, Prisma__ActionItemClient<ActionItem | null>, Prisma__ActionItemClient<ActionItemGetPayload<T> | null>>
  /**
   * Find zero or more ActionItems that matches the filter.
   * @param {FindManyActionItemArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all ActionItems
   * const actionItems = await prisma.actionItem.findMany()
   * 
   * // Get first 10 ActionItems
   * const actionItems = await prisma.actionItem.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const actionItemWithIdOnly = await prisma.actionItem.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyActionItemArgs>(
    args?: Subset<T, FindManyActionItemArgs>
  ): CheckSelect<T, Promise<Array<ActionItem>>, Promise<Array<ActionItemGetPayload<T>>>>
  /**
   * Create a ActionItem.
   * @param {ActionItemCreateArgs} args - Arguments to create a ActionItem.
   * @example
   * // Create one ActionItem
   * const ActionItem = await prisma.actionItem.create({
   *   data: {
   *     // ... data to create a ActionItem
   *   }
   * })
   * 
  **/
  create<T extends ActionItemCreateArgs>(
    args: Subset<T, ActionItemCreateArgs>
  ): CheckSelect<T, Prisma__ActionItemClient<ActionItem>, Prisma__ActionItemClient<ActionItemGetPayload<T>>>
  /**
   * Delete a ActionItem.
   * @param {ActionItemDeleteArgs} args - Arguments to delete one ActionItem.
   * @example
   * // Delete one ActionItem
   * const ActionItem = await prisma.actionItem.delete({
   *   where: {
   *     // ... filter to delete one ActionItem
   *   }
   * })
   * 
  **/
  delete<T extends ActionItemDeleteArgs>(
    args: Subset<T, ActionItemDeleteArgs>
  ): CheckSelect<T, Prisma__ActionItemClient<ActionItem>, Prisma__ActionItemClient<ActionItemGetPayload<T>>>
  /**
   * Update one ActionItem.
   * @param {ActionItemUpdateArgs} args - Arguments to update one ActionItem.
   * @example
   * // Update one ActionItem
   * const actionItem = await prisma.actionItem.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends ActionItemUpdateArgs>(
    args: Subset<T, ActionItemUpdateArgs>
  ): CheckSelect<T, Prisma__ActionItemClient<ActionItem>, Prisma__ActionItemClient<ActionItemGetPayload<T>>>
  /**
   * Delete zero or more ActionItems.
   * @param {ActionItemDeleteManyArgs} args - Arguments to filter ActionItems to delete.
   * @example
   * // Delete a few ActionItems
   * const { count } = await prisma.actionItem.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends ActionItemDeleteManyArgs>(
    args: Subset<T, ActionItemDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more ActionItems.
   * @param {ActionItemUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many ActionItems
   * const actionItem = await prisma.actionItem.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends ActionItemUpdateManyArgs>(
    args: Subset<T, ActionItemUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one ActionItem.
   * @param {ActionItemUpsertArgs} args - Arguments to update or create a ActionItem.
   * @example
   * // Update or create a ActionItem
   * const actionItem = await prisma.actionItem.upsert({
   *   create: {
   *     // ... data to create a ActionItem
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the ActionItem we want to update
   *   }
   * })
  **/
  upsert<T extends ActionItemUpsertArgs>(
    args: Subset<T, ActionItemUpsertArgs>
  ): CheckSelect<T, Prisma__ActionItemClient<ActionItem>, Prisma__ActionItemClient<ActionItemGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyActionItemArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateActionItemArgs>(args: Subset<T, AggregateActionItemArgs>): Promise<GetActionItemAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for ActionItem.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__ActionItemClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  Student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null>, Prisma__StudentClient<StudentGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * ActionItem findOne
 */
export type FindOneActionItemArgs = {
  /**
   * Select specific fields to fetch from the ActionItem
  **/
  select?: ActionItemSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ActionItemInclude | null
  /**
   * Filter, which ActionItem to fetch.
  **/
  where: ActionItemWhereUniqueInput
}


/**
 * ActionItem findFirst
 */
export type FindFirstActionItemArgs = {
  /**
   * Select specific fields to fetch from the ActionItem
  **/
  select?: ActionItemSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ActionItemInclude | null
  /**
   * Filter, which ActionItem to fetch.
  **/
  where?: ActionItemWhereInput
  orderBy?: Enumerable<ActionItemOrderByInput> | ActionItemOrderByInput
  cursor?: ActionItemWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ActionItemDistinctFieldEnum>
}


/**
 * ActionItem findMany
 */
export type FindManyActionItemArgs = {
  /**
   * Select specific fields to fetch from the ActionItem
  **/
  select?: ActionItemSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ActionItemInclude | null
  /**
   * Filter, which ActionItems to fetch.
  **/
  where?: ActionItemWhereInput
  /**
   * Determine the order of the ActionItems to fetch.
  **/
  orderBy?: Enumerable<ActionItemOrderByInput> | ActionItemOrderByInput
  /**
   * Sets the position for listing ActionItems.
  **/
  cursor?: ActionItemWhereUniqueInput
  /**
   * The number of ActionItems to fetch. If negative number, it will take ActionItems before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` ActionItems.
  **/
  skip?: number
  distinct?: Enumerable<ActionItemDistinctFieldEnum>
}


/**
 * ActionItem create
 */
export type ActionItemCreateArgs = {
  /**
   * Select specific fields to fetch from the ActionItem
  **/
  select?: ActionItemSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ActionItemInclude | null
  /**
   * The data needed to create a ActionItem.
  **/
  data: ActionItemCreateInput
}


/**
 * ActionItem update
 */
export type ActionItemUpdateArgs = {
  /**
   * Select specific fields to fetch from the ActionItem
  **/
  select?: ActionItemSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ActionItemInclude | null
  /**
   * The data needed to update a ActionItem.
  **/
  data: ActionItemUpdateInput
  /**
   * Choose, which ActionItem to update.
  **/
  where: ActionItemWhereUniqueInput
}


/**
 * ActionItem updateMany
 */
export type ActionItemUpdateManyArgs = {
  data: ActionItemUpdateManyMutationInput
  where?: ActionItemWhereInput
}


/**
 * ActionItem upsert
 */
export type ActionItemUpsertArgs = {
  /**
   * Select specific fields to fetch from the ActionItem
  **/
  select?: ActionItemSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ActionItemInclude | null
  /**
   * The filter to search for the ActionItem to update in case it exists.
  **/
  where: ActionItemWhereUniqueInput
  /**
   * In case the ActionItem found by the `where` argument doesn't exist, create a new ActionItem with this data.
  **/
  create: ActionItemCreateInput
  /**
   * In case the ActionItem was found with the provided `where` argument, update it with this data.
  **/
  update: ActionItemUpdateInput
}


/**
 * ActionItem delete
 */
export type ActionItemDeleteArgs = {
  /**
   * Select specific fields to fetch from the ActionItem
  **/
  select?: ActionItemSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ActionItemInclude | null
  /**
   * Filter which ActionItem to delete.
  **/
  where: ActionItemWhereUniqueInput
}


/**
 * ActionItem deleteMany
 */
export type ActionItemDeleteManyArgs = {
  where?: ActionItemWhereInput
}


/**
 * ActionItem without action
 */
export type ActionItemArgs = {
  /**
   * Select specific fields to fetch from the ActionItem
  **/
  select?: ActionItemSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ActionItemInclude | null
}



/**
 * Model Contact
 */

export type Contact = {
  id: number
  primary: boolean
  name: string
  relationship: string
  number: string
  ext: number
  country: string
  studentId: number | null
}


export type AggregateContact = {
  count: number
  avg: ContactAvgAggregateOutputType | null
  sum: ContactSumAggregateOutputType | null
  min: ContactMinAggregateOutputType | null
  max: ContactMaxAggregateOutputType | null
}

export type ContactAvgAggregateOutputType = {
  id: number
  ext: number
  studentId: number | null
}

export type ContactSumAggregateOutputType = {
  id: number
  ext: number
  studentId: number | null
}

export type ContactMinAggregateOutputType = {
  id: number
  ext: number
  studentId: number | null
}

export type ContactMaxAggregateOutputType = {
  id: number
  ext: number
  studentId: number | null
}


export type ContactAvgAggregateInputType = {
  id?: true
  ext?: true
  studentId?: true
}

export type ContactSumAggregateInputType = {
  id?: true
  ext?: true
  studentId?: true
}

export type ContactMinAggregateInputType = {
  id?: true
  ext?: true
  studentId?: true
}

export type ContactMaxAggregateInputType = {
  id?: true
  ext?: true
  studentId?: true
}

export type AggregateContactArgs = {
  where?: ContactWhereInput
  orderBy?: Enumerable<ContactOrderByInput> | ContactOrderByInput
  cursor?: ContactWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ContactDistinctFieldEnum>
  count?: true
  avg?: ContactAvgAggregateInputType
  sum?: ContactSumAggregateInputType
  min?: ContactMinAggregateInputType
  max?: ContactMaxAggregateInputType
}

export type GetContactAggregateType<T extends AggregateContactArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetContactAggregateScalarType<T[P]>
}

export type GetContactAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof ContactAvgAggregateOutputType ? ContactAvgAggregateOutputType[P] : never
}
    
    

export type ContactSelect = {
  id?: boolean
  primary?: boolean
  name?: boolean
  relationship?: boolean
  number?: boolean
  ext?: boolean
  country?: boolean
  Student?: boolean | StudentArgs
  studentId?: boolean
}

export type ContactInclude = {
  Student?: boolean | StudentArgs
}

export type ContactGetPayload<
  S extends boolean | null | undefined | ContactArgs,
  U = keyof S
> = S extends true
  ? Contact
  : S extends undefined
  ? never
  : S extends ContactArgs | FindManyContactArgs
  ? 'include' extends U
    ? Contact  & {
      [P in TrueKeys<S['include']>]:
      P extends 'Student'
      ? StudentGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Contact ? Contact[P]
: 
      P extends 'Student'
      ? StudentGetPayload<S['select'][P]> | null : never
    }
  : Contact
: Contact


export interface ContactDelegate {
  /**
   * Find zero or one Contact that matches the filter.
   * @param {FindOneContactArgs} args - Arguments to find a Contact
   * @example
   * // Get one Contact
   * const contact = await prisma.contact.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneContactArgs>(
    args: Subset<T, FindOneContactArgs>
  ): CheckSelect<T, Prisma__ContactClient<Contact | null>, Prisma__ContactClient<ContactGetPayload<T> | null>>
  /**
   * Find the first Contact that matches the filter.
   * @param {FindFirstContactArgs} args - Arguments to find a Contact
   * @example
   * // Get one Contact
   * const contact = await prisma.contact.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstContactArgs>(
    args?: Subset<T, FindFirstContactArgs>
  ): CheckSelect<T, Prisma__ContactClient<Contact | null>, Prisma__ContactClient<ContactGetPayload<T> | null>>
  /**
   * Find zero or more Contacts that matches the filter.
   * @param {FindManyContactArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Contacts
   * const contacts = await prisma.contact.findMany()
   * 
   * // Get first 10 Contacts
   * const contacts = await prisma.contact.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyContactArgs>(
    args?: Subset<T, FindManyContactArgs>
  ): CheckSelect<T, Promise<Array<Contact>>, Promise<Array<ContactGetPayload<T>>>>
  /**
   * Create a Contact.
   * @param {ContactCreateArgs} args - Arguments to create a Contact.
   * @example
   * // Create one Contact
   * const Contact = await prisma.contact.create({
   *   data: {
   *     // ... data to create a Contact
   *   }
   * })
   * 
  **/
  create<T extends ContactCreateArgs>(
    args: Subset<T, ContactCreateArgs>
  ): CheckSelect<T, Prisma__ContactClient<Contact>, Prisma__ContactClient<ContactGetPayload<T>>>
  /**
   * Delete a Contact.
   * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
   * @example
   * // Delete one Contact
   * const Contact = await prisma.contact.delete({
   *   where: {
   *     // ... filter to delete one Contact
   *   }
   * })
   * 
  **/
  delete<T extends ContactDeleteArgs>(
    args: Subset<T, ContactDeleteArgs>
  ): CheckSelect<T, Prisma__ContactClient<Contact>, Prisma__ContactClient<ContactGetPayload<T>>>
  /**
   * Update one Contact.
   * @param {ContactUpdateArgs} args - Arguments to update one Contact.
   * @example
   * // Update one Contact
   * const contact = await prisma.contact.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends ContactUpdateArgs>(
    args: Subset<T, ContactUpdateArgs>
  ): CheckSelect<T, Prisma__ContactClient<Contact>, Prisma__ContactClient<ContactGetPayload<T>>>
  /**
   * Delete zero or more Contacts.
   * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
   * @example
   * // Delete a few Contacts
   * const { count } = await prisma.contact.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends ContactDeleteManyArgs>(
    args: Subset<T, ContactDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Contacts.
   * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Contacts
   * const contact = await prisma.contact.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends ContactUpdateManyArgs>(
    args: Subset<T, ContactUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Contact.
   * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
   * @example
   * // Update or create a Contact
   * const contact = await prisma.contact.upsert({
   *   create: {
   *     // ... data to create a Contact
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Contact we want to update
   *   }
   * })
  **/
  upsert<T extends ContactUpsertArgs>(
    args: Subset<T, ContactUpsertArgs>
  ): CheckSelect<T, Prisma__ContactClient<Contact>, Prisma__ContactClient<ContactGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyContactArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateContactArgs>(args: Subset<T, AggregateContactArgs>): Promise<GetContactAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Contact.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__ContactClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  Student<T extends StudentArgs = {}>(args?: Subset<T, StudentArgs>): CheckSelect<T, Prisma__StudentClient<Student | null>, Prisma__StudentClient<StudentGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Contact findOne
 */
export type FindOneContactArgs = {
  /**
   * Select specific fields to fetch from the Contact
  **/
  select?: ContactSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContactInclude | null
  /**
   * Filter, which Contact to fetch.
  **/
  where: ContactWhereUniqueInput
}


/**
 * Contact findFirst
 */
export type FindFirstContactArgs = {
  /**
   * Select specific fields to fetch from the Contact
  **/
  select?: ContactSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContactInclude | null
  /**
   * Filter, which Contact to fetch.
  **/
  where?: ContactWhereInput
  orderBy?: Enumerable<ContactOrderByInput> | ContactOrderByInput
  cursor?: ContactWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ContactDistinctFieldEnum>
}


/**
 * Contact findMany
 */
export type FindManyContactArgs = {
  /**
   * Select specific fields to fetch from the Contact
  **/
  select?: ContactSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContactInclude | null
  /**
   * Filter, which Contacts to fetch.
  **/
  where?: ContactWhereInput
  /**
   * Determine the order of the Contacts to fetch.
  **/
  orderBy?: Enumerable<ContactOrderByInput> | ContactOrderByInput
  /**
   * Sets the position for listing Contacts.
  **/
  cursor?: ContactWhereUniqueInput
  /**
   * The number of Contacts to fetch. If negative number, it will take Contacts before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Contacts.
  **/
  skip?: number
  distinct?: Enumerable<ContactDistinctFieldEnum>
}


/**
 * Contact create
 */
export type ContactCreateArgs = {
  /**
   * Select specific fields to fetch from the Contact
  **/
  select?: ContactSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContactInclude | null
  /**
   * The data needed to create a Contact.
  **/
  data: ContactCreateInput
}


/**
 * Contact update
 */
export type ContactUpdateArgs = {
  /**
   * Select specific fields to fetch from the Contact
  **/
  select?: ContactSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContactInclude | null
  /**
   * The data needed to update a Contact.
  **/
  data: ContactUpdateInput
  /**
   * Choose, which Contact to update.
  **/
  where: ContactWhereUniqueInput
}


/**
 * Contact updateMany
 */
export type ContactUpdateManyArgs = {
  data: ContactUpdateManyMutationInput
  where?: ContactWhereInput
}


/**
 * Contact upsert
 */
export type ContactUpsertArgs = {
  /**
   * Select specific fields to fetch from the Contact
  **/
  select?: ContactSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContactInclude | null
  /**
   * The filter to search for the Contact to update in case it exists.
  **/
  where: ContactWhereUniqueInput
  /**
   * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
  **/
  create: ContactCreateInput
  /**
   * In case the Contact was found with the provided `where` argument, update it with this data.
  **/
  update: ContactUpdateInput
}


/**
 * Contact delete
 */
export type ContactDeleteArgs = {
  /**
   * Select specific fields to fetch from the Contact
  **/
  select?: ContactSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContactInclude | null
  /**
   * Filter which Contact to delete.
  **/
  where: ContactWhereUniqueInput
}


/**
 * Contact deleteMany
 */
export type ContactDeleteManyArgs = {
  where?: ContactWhereInput
}


/**
 * Contact without action
 */
export type ContactArgs = {
  /**
   * Select specific fields to fetch from the Contact
  **/
  select?: ContactSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ContactInclude | null
}



/**
 * Model Class
 */

export type Class = {
  id: number
  name: string
  code: string
  title: string
  days: string
  time: string
  location: string
  teacherId: number | null
}


export type AggregateClass = {
  count: number
  avg: ClassAvgAggregateOutputType | null
  sum: ClassSumAggregateOutputType | null
  min: ClassMinAggregateOutputType | null
  max: ClassMaxAggregateOutputType | null
}

export type ClassAvgAggregateOutputType = {
  id: number
  teacherId: number | null
}

export type ClassSumAggregateOutputType = {
  id: number
  teacherId: number | null
}

export type ClassMinAggregateOutputType = {
  id: number
  teacherId: number | null
}

export type ClassMaxAggregateOutputType = {
  id: number
  teacherId: number | null
}


export type ClassAvgAggregateInputType = {
  id?: true
  teacherId?: true
}

export type ClassSumAggregateInputType = {
  id?: true
  teacherId?: true
}

export type ClassMinAggregateInputType = {
  id?: true
  teacherId?: true
}

export type ClassMaxAggregateInputType = {
  id?: true
  teacherId?: true
}

export type AggregateClassArgs = {
  where?: ClassWhereInput
  orderBy?: Enumerable<ClassOrderByInput> | ClassOrderByInput
  cursor?: ClassWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ClassDistinctFieldEnum>
  count?: true
  avg?: ClassAvgAggregateInputType
  sum?: ClassSumAggregateInputType
  min?: ClassMinAggregateInputType
  max?: ClassMaxAggregateInputType
}

export type GetClassAggregateType<T extends AggregateClassArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetClassAggregateScalarType<T[P]>
}

export type GetClassAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof ClassAvgAggregateOutputType ? ClassAvgAggregateOutputType[P] : never
}
    
    

export type ClassSelect = {
  id?: boolean
  name?: boolean
  code?: boolean
  title?: boolean
  days?: boolean
  time?: boolean
  location?: boolean
  students?: boolean | FindManyStudentArgs
  Teacher?: boolean | TeacherArgs
  teacherId?: boolean
}

export type ClassInclude = {
  students?: boolean | FindManyStudentArgs
  Teacher?: boolean | TeacherArgs
}

export type ClassGetPayload<
  S extends boolean | null | undefined | ClassArgs,
  U = keyof S
> = S extends true
  ? Class
  : S extends undefined
  ? never
  : S extends ClassArgs | FindManyClassArgs
  ? 'include' extends U
    ? Class  & {
      [P in TrueKeys<S['include']>]:
      P extends 'students'
      ? Array<StudentGetPayload<S['include'][P]>> :
      P extends 'Teacher'
      ? TeacherGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Class ? Class[P]
: 
      P extends 'students'
      ? Array<StudentGetPayload<S['select'][P]>> :
      P extends 'Teacher'
      ? TeacherGetPayload<S['select'][P]> | null : never
    }
  : Class
: Class


export interface ClassDelegate {
  /**
   * Find zero or one Class that matches the filter.
   * @param {FindOneClassArgs} args - Arguments to find a Class
   * @example
   * // Get one Class
   * const class = await prisma.class.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneClassArgs>(
    args: Subset<T, FindOneClassArgs>
  ): CheckSelect<T, Prisma__ClassClient<Class | null>, Prisma__ClassClient<ClassGetPayload<T> | null>>
  /**
   * Find the first Class that matches the filter.
   * @param {FindFirstClassArgs} args - Arguments to find a Class
   * @example
   * // Get one Class
   * const class = await prisma.class.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstClassArgs>(
    args?: Subset<T, FindFirstClassArgs>
  ): CheckSelect<T, Prisma__ClassClient<Class | null>, Prisma__ClassClient<ClassGetPayload<T> | null>>
  /**
   * Find zero or more Classes that matches the filter.
   * @param {FindManyClassArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Classes
   * const classes = await prisma.class.findMany()
   * 
   * // Get first 10 Classes
   * const classes = await prisma.class.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyClassArgs>(
    args?: Subset<T, FindManyClassArgs>
  ): CheckSelect<T, Promise<Array<Class>>, Promise<Array<ClassGetPayload<T>>>>
  /**
   * Create a Class.
   * @param {ClassCreateArgs} args - Arguments to create a Class.
   * @example
   * // Create one Class
   * const Class = await prisma.class.create({
   *   data: {
   *     // ... data to create a Class
   *   }
   * })
   * 
  **/
  create<T extends ClassCreateArgs>(
    args: Subset<T, ClassCreateArgs>
  ): CheckSelect<T, Prisma__ClassClient<Class>, Prisma__ClassClient<ClassGetPayload<T>>>
  /**
   * Delete a Class.
   * @param {ClassDeleteArgs} args - Arguments to delete one Class.
   * @example
   * // Delete one Class
   * const Class = await prisma.class.delete({
   *   where: {
   *     // ... filter to delete one Class
   *   }
   * })
   * 
  **/
  delete<T extends ClassDeleteArgs>(
    args: Subset<T, ClassDeleteArgs>
  ): CheckSelect<T, Prisma__ClassClient<Class>, Prisma__ClassClient<ClassGetPayload<T>>>
  /**
   * Update one Class.
   * @param {ClassUpdateArgs} args - Arguments to update one Class.
   * @example
   * // Update one Class
   * const class = await prisma.class.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends ClassUpdateArgs>(
    args: Subset<T, ClassUpdateArgs>
  ): CheckSelect<T, Prisma__ClassClient<Class>, Prisma__ClassClient<ClassGetPayload<T>>>
  /**
   * Delete zero or more Classes.
   * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
   * @example
   * // Delete a few Classes
   * const { count } = await prisma.class.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends ClassDeleteManyArgs>(
    args: Subset<T, ClassDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Classes.
   * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Classes
   * const class = await prisma.class.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends ClassUpdateManyArgs>(
    args: Subset<T, ClassUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Class.
   * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
   * @example
   * // Update or create a Class
   * const class = await prisma.class.upsert({
   *   create: {
   *     // ... data to create a Class
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Class we want to update
   *   }
   * })
  **/
  upsert<T extends ClassUpsertArgs>(
    args: Subset<T, ClassUpsertArgs>
  ): CheckSelect<T, Prisma__ClassClient<Class>, Prisma__ClassClient<ClassGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyClassArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateClassArgs>(args: Subset<T, AggregateClassArgs>): Promise<GetClassAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Class.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__ClassClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  students<T extends FindManyStudentArgs = {}>(args?: Subset<T, FindManyStudentArgs>): CheckSelect<T, Promise<Array<Student>>, Promise<Array<StudentGetPayload<T>>>>;

  Teacher<T extends TeacherArgs = {}>(args?: Subset<T, TeacherArgs>): CheckSelect<T, Prisma__TeacherClient<Teacher | null>, Prisma__TeacherClient<TeacherGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Class findOne
 */
export type FindOneClassArgs = {
  /**
   * Select specific fields to fetch from the Class
  **/
  select?: ClassSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ClassInclude | null
  /**
   * Filter, which Class to fetch.
  **/
  where: ClassWhereUniqueInput
}


/**
 * Class findFirst
 */
export type FindFirstClassArgs = {
  /**
   * Select specific fields to fetch from the Class
  **/
  select?: ClassSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ClassInclude | null
  /**
   * Filter, which Class to fetch.
  **/
  where?: ClassWhereInput
  orderBy?: Enumerable<ClassOrderByInput> | ClassOrderByInput
  cursor?: ClassWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ClassDistinctFieldEnum>
}


/**
 * Class findMany
 */
export type FindManyClassArgs = {
  /**
   * Select specific fields to fetch from the Class
  **/
  select?: ClassSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ClassInclude | null
  /**
   * Filter, which Classes to fetch.
  **/
  where?: ClassWhereInput
  /**
   * Determine the order of the Classes to fetch.
  **/
  orderBy?: Enumerable<ClassOrderByInput> | ClassOrderByInput
  /**
   * Sets the position for listing Classes.
  **/
  cursor?: ClassWhereUniqueInput
  /**
   * The number of Classes to fetch. If negative number, it will take Classes before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Classes.
  **/
  skip?: number
  distinct?: Enumerable<ClassDistinctFieldEnum>
}


/**
 * Class create
 */
export type ClassCreateArgs = {
  /**
   * Select specific fields to fetch from the Class
  **/
  select?: ClassSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ClassInclude | null
  /**
   * The data needed to create a Class.
  **/
  data: ClassCreateInput
}


/**
 * Class update
 */
export type ClassUpdateArgs = {
  /**
   * Select specific fields to fetch from the Class
  **/
  select?: ClassSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ClassInclude | null
  /**
   * The data needed to update a Class.
  **/
  data: ClassUpdateInput
  /**
   * Choose, which Class to update.
  **/
  where: ClassWhereUniqueInput
}


/**
 * Class updateMany
 */
export type ClassUpdateManyArgs = {
  data: ClassUpdateManyMutationInput
  where?: ClassWhereInput
}


/**
 * Class upsert
 */
export type ClassUpsertArgs = {
  /**
   * Select specific fields to fetch from the Class
  **/
  select?: ClassSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ClassInclude | null
  /**
   * The filter to search for the Class to update in case it exists.
  **/
  where: ClassWhereUniqueInput
  /**
   * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
  **/
  create: ClassCreateInput
  /**
   * In case the Class was found with the provided `where` argument, update it with this data.
  **/
  update: ClassUpdateInput
}


/**
 * Class delete
 */
export type ClassDeleteArgs = {
  /**
   * Select specific fields to fetch from the Class
  **/
  select?: ClassSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ClassInclude | null
  /**
   * Filter which Class to delete.
  **/
  where: ClassWhereUniqueInput
}


/**
 * Class deleteMany
 */
export type ClassDeleteManyArgs = {
  where?: ClassWhereInput
}


/**
 * Class without action
 */
export type ClassArgs = {
  /**
   * Select specific fields to fetch from the Class
  **/
  select?: ClassSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ClassInclude | null
}



/**
 * Model Teacher
 */

export type Teacher = {
  id: number
  email: string
  name: string
}


export type AggregateTeacher = {
  count: number
  avg: TeacherAvgAggregateOutputType | null
  sum: TeacherSumAggregateOutputType | null
  min: TeacherMinAggregateOutputType | null
  max: TeacherMaxAggregateOutputType | null
}

export type TeacherAvgAggregateOutputType = {
  id: number
}

export type TeacherSumAggregateOutputType = {
  id: number
}

export type TeacherMinAggregateOutputType = {
  id: number
}

export type TeacherMaxAggregateOutputType = {
  id: number
}


export type TeacherAvgAggregateInputType = {
  id?: true
}

export type TeacherSumAggregateInputType = {
  id?: true
}

export type TeacherMinAggregateInputType = {
  id?: true
}

export type TeacherMaxAggregateInputType = {
  id?: true
}

export type AggregateTeacherArgs = {
  where?: TeacherWhereInput
  orderBy?: Enumerable<TeacherOrderByInput> | TeacherOrderByInput
  cursor?: TeacherWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<TeacherDistinctFieldEnum>
  count?: true
  avg?: TeacherAvgAggregateInputType
  sum?: TeacherSumAggregateInputType
  min?: TeacherMinAggregateInputType
  max?: TeacherMaxAggregateInputType
}

export type GetTeacherAggregateType<T extends AggregateTeacherArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetTeacherAggregateScalarType<T[P]>
}

export type GetTeacherAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof TeacherAvgAggregateOutputType ? TeacherAvgAggregateOutputType[P] : never
}
    
    

export type TeacherSelect = {
  id?: boolean
  email?: boolean
  name?: boolean
  Class?: boolean | FindManyClassArgs
  Student?: boolean | FindManyStudentArgs
}

export type TeacherInclude = {
  Class?: boolean | FindManyClassArgs
  Student?: boolean | FindManyStudentArgs
}

export type TeacherGetPayload<
  S extends boolean | null | undefined | TeacherArgs,
  U = keyof S
> = S extends true
  ? Teacher
  : S extends undefined
  ? never
  : S extends TeacherArgs | FindManyTeacherArgs
  ? 'include' extends U
    ? Teacher  & {
      [P in TrueKeys<S['include']>]:
      P extends 'Class'
      ? Array<ClassGetPayload<S['include'][P]>> :
      P extends 'Student'
      ? Array<StudentGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Teacher ? Teacher[P]
: 
      P extends 'Class'
      ? Array<ClassGetPayload<S['select'][P]>> :
      P extends 'Student'
      ? Array<StudentGetPayload<S['select'][P]>> : never
    }
  : Teacher
: Teacher


export interface TeacherDelegate {
  /**
   * Find zero or one Teacher that matches the filter.
   * @param {FindOneTeacherArgs} args - Arguments to find a Teacher
   * @example
   * // Get one Teacher
   * const teacher = await prisma.teacher.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneTeacherArgs>(
    args: Subset<T, FindOneTeacherArgs>
  ): CheckSelect<T, Prisma__TeacherClient<Teacher | null>, Prisma__TeacherClient<TeacherGetPayload<T> | null>>
  /**
   * Find the first Teacher that matches the filter.
   * @param {FindFirstTeacherArgs} args - Arguments to find a Teacher
   * @example
   * // Get one Teacher
   * const teacher = await prisma.teacher.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstTeacherArgs>(
    args?: Subset<T, FindFirstTeacherArgs>
  ): CheckSelect<T, Prisma__TeacherClient<Teacher | null>, Prisma__TeacherClient<TeacherGetPayload<T> | null>>
  /**
   * Find zero or more Teachers that matches the filter.
   * @param {FindManyTeacherArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Teachers
   * const teachers = await prisma.teacher.findMany()
   * 
   * // Get first 10 Teachers
   * const teachers = await prisma.teacher.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const teacherWithIdOnly = await prisma.teacher.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyTeacherArgs>(
    args?: Subset<T, FindManyTeacherArgs>
  ): CheckSelect<T, Promise<Array<Teacher>>, Promise<Array<TeacherGetPayload<T>>>>
  /**
   * Create a Teacher.
   * @param {TeacherCreateArgs} args - Arguments to create a Teacher.
   * @example
   * // Create one Teacher
   * const Teacher = await prisma.teacher.create({
   *   data: {
   *     // ... data to create a Teacher
   *   }
   * })
   * 
  **/
  create<T extends TeacherCreateArgs>(
    args: Subset<T, TeacherCreateArgs>
  ): CheckSelect<T, Prisma__TeacherClient<Teacher>, Prisma__TeacherClient<TeacherGetPayload<T>>>
  /**
   * Delete a Teacher.
   * @param {TeacherDeleteArgs} args - Arguments to delete one Teacher.
   * @example
   * // Delete one Teacher
   * const Teacher = await prisma.teacher.delete({
   *   where: {
   *     // ... filter to delete one Teacher
   *   }
   * })
   * 
  **/
  delete<T extends TeacherDeleteArgs>(
    args: Subset<T, TeacherDeleteArgs>
  ): CheckSelect<T, Prisma__TeacherClient<Teacher>, Prisma__TeacherClient<TeacherGetPayload<T>>>
  /**
   * Update one Teacher.
   * @param {TeacherUpdateArgs} args - Arguments to update one Teacher.
   * @example
   * // Update one Teacher
   * const teacher = await prisma.teacher.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends TeacherUpdateArgs>(
    args: Subset<T, TeacherUpdateArgs>
  ): CheckSelect<T, Prisma__TeacherClient<Teacher>, Prisma__TeacherClient<TeacherGetPayload<T>>>
  /**
   * Delete zero or more Teachers.
   * @param {TeacherDeleteManyArgs} args - Arguments to filter Teachers to delete.
   * @example
   * // Delete a few Teachers
   * const { count } = await prisma.teacher.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends TeacherDeleteManyArgs>(
    args: Subset<T, TeacherDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Teachers.
   * @param {TeacherUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Teachers
   * const teacher = await prisma.teacher.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends TeacherUpdateManyArgs>(
    args: Subset<T, TeacherUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Teacher.
   * @param {TeacherUpsertArgs} args - Arguments to update or create a Teacher.
   * @example
   * // Update or create a Teacher
   * const teacher = await prisma.teacher.upsert({
   *   create: {
   *     // ... data to create a Teacher
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Teacher we want to update
   *   }
   * })
  **/
  upsert<T extends TeacherUpsertArgs>(
    args: Subset<T, TeacherUpsertArgs>
  ): CheckSelect<T, Prisma__TeacherClient<Teacher>, Prisma__TeacherClient<TeacherGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyTeacherArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateTeacherArgs>(args: Subset<T, AggregateTeacherArgs>): Promise<GetTeacherAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Teacher.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__TeacherClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  Class<T extends FindManyClassArgs = {}>(args?: Subset<T, FindManyClassArgs>): CheckSelect<T, Promise<Array<Class>>, Promise<Array<ClassGetPayload<T>>>>;

  Student<T extends FindManyStudentArgs = {}>(args?: Subset<T, FindManyStudentArgs>): CheckSelect<T, Promise<Array<Student>>, Promise<Array<StudentGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Teacher findOne
 */
export type FindOneTeacherArgs = {
  /**
   * Select specific fields to fetch from the Teacher
  **/
  select?: TeacherSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TeacherInclude | null
  /**
   * Filter, which Teacher to fetch.
  **/
  where: TeacherWhereUniqueInput
}


/**
 * Teacher findFirst
 */
export type FindFirstTeacherArgs = {
  /**
   * Select specific fields to fetch from the Teacher
  **/
  select?: TeacherSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TeacherInclude | null
  /**
   * Filter, which Teacher to fetch.
  **/
  where?: TeacherWhereInput
  orderBy?: Enumerable<TeacherOrderByInput> | TeacherOrderByInput
  cursor?: TeacherWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<TeacherDistinctFieldEnum>
}


/**
 * Teacher findMany
 */
export type FindManyTeacherArgs = {
  /**
   * Select specific fields to fetch from the Teacher
  **/
  select?: TeacherSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TeacherInclude | null
  /**
   * Filter, which Teachers to fetch.
  **/
  where?: TeacherWhereInput
  /**
   * Determine the order of the Teachers to fetch.
  **/
  orderBy?: Enumerable<TeacherOrderByInput> | TeacherOrderByInput
  /**
   * Sets the position for listing Teachers.
  **/
  cursor?: TeacherWhereUniqueInput
  /**
   * The number of Teachers to fetch. If negative number, it will take Teachers before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Teachers.
  **/
  skip?: number
  distinct?: Enumerable<TeacherDistinctFieldEnum>
}


/**
 * Teacher create
 */
export type TeacherCreateArgs = {
  /**
   * Select specific fields to fetch from the Teacher
  **/
  select?: TeacherSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TeacherInclude | null
  /**
   * The data needed to create a Teacher.
  **/
  data: TeacherCreateInput
}


/**
 * Teacher update
 */
export type TeacherUpdateArgs = {
  /**
   * Select specific fields to fetch from the Teacher
  **/
  select?: TeacherSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TeacherInclude | null
  /**
   * The data needed to update a Teacher.
  **/
  data: TeacherUpdateInput
  /**
   * Choose, which Teacher to update.
  **/
  where: TeacherWhereUniqueInput
}


/**
 * Teacher updateMany
 */
export type TeacherUpdateManyArgs = {
  data: TeacherUpdateManyMutationInput
  where?: TeacherWhereInput
}


/**
 * Teacher upsert
 */
export type TeacherUpsertArgs = {
  /**
   * Select specific fields to fetch from the Teacher
  **/
  select?: TeacherSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TeacherInclude | null
  /**
   * The filter to search for the Teacher to update in case it exists.
  **/
  where: TeacherWhereUniqueInput
  /**
   * In case the Teacher found by the `where` argument doesn't exist, create a new Teacher with this data.
  **/
  create: TeacherCreateInput
  /**
   * In case the Teacher was found with the provided `where` argument, update it with this data.
  **/
  update: TeacherUpdateInput
}


/**
 * Teacher delete
 */
export type TeacherDeleteArgs = {
  /**
   * Select specific fields to fetch from the Teacher
  **/
  select?: TeacherSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TeacherInclude | null
  /**
   * Filter which Teacher to delete.
  **/
  where: TeacherWhereUniqueInput
}


/**
 * Teacher deleteMany
 */
export type TeacherDeleteManyArgs = {
  where?: TeacherWhereInput
}


/**
 * Teacher without action
 */
export type TeacherArgs = {
  /**
   * Select specific fields to fetch from the Teacher
  **/
  select?: TeacherSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TeacherInclude | null
}



/**
 * Deep Input Types
 */


export type StudentWhereInput = {
  AND?: StudentWhereInput | Enumerable<StudentWhereInput>
  OR?: StudentWhereInput | Enumerable<StudentWhereInput>
  NOT?: StudentWhereInput | Enumerable<StudentWhereInput>
  id?: IntFilter | number
  studentID?: IntFilter | number
  profilePicURL?: StringFilter | string
  creditsCompleted?: IntFilter | number
  gender?: StringFilter | string
  dob?: StringFilter | string
  birthCountry?: StringFilter | string
  birthState?: StringFilter | string
  maritialStatus?: StringFilter | string
  militaryStatus?: StringFilter | string
  citizenshipStatus?: StringFilter | string
  citizenshipCountry?: StringFilter | string
  visaType?: StringFilter | string
  visaPermit?: StringFilter | string
  visaCountry?: StringFilter | string
  names?: NameListRelationFilter
  addresses?: AddressListRelationFilter
  phonenumbers?: PhoneNumberListRelationFilter
  emails?: EmailAddressListRelationFilter
  contacts?: ContactListRelationFilter
  finance?: FinanceRelationFilter | FinanceWhereInput | null
  financeId?: IntNullableFilter | number | null
  actionItems?: ActionItemListRelationFilter
  advisor?: TeacherRelationFilter | TeacherWhereInput | null
  advisorId?: IntNullableFilter | number | null
  classes?: ClassListRelationFilter
}

export type StudentOrderByInput = {
  id?: SortOrder
  studentID?: SortOrder
  profilePicURL?: SortOrder
  creditsCompleted?: SortOrder
  gender?: SortOrder
  dob?: SortOrder
  birthCountry?: SortOrder
  birthState?: SortOrder
  maritialStatus?: SortOrder
  militaryStatus?: SortOrder
  citizenshipStatus?: SortOrder
  citizenshipCountry?: SortOrder
  visaType?: SortOrder
  visaPermit?: SortOrder
  visaCountry?: SortOrder
  financeId?: SortOrder
  advisorId?: SortOrder
}

export type StudentWhereUniqueInput = {
  id?: number
}

export type NameWhereInput = {
  AND?: NameWhereInput | Enumerable<NameWhereInput>
  OR?: NameWhereInput | Enumerable<NameWhereInput>
  NOT?: NameWhereInput | Enumerable<NameWhereInput>
  id?: IntFilter | number
  name?: StringFilter | string
  type?: StringFilter | string
  Student?: StudentRelationFilter | StudentWhereInput | null
  studentId?: IntNullableFilter | number | null
}

export type NameOrderByInput = {
  id?: SortOrder
  name?: SortOrder
  type?: SortOrder
  studentId?: SortOrder
}

export type NameWhereUniqueInput = {
  id?: number
}

export type AddressWhereInput = {
  AND?: AddressWhereInput | Enumerable<AddressWhereInput>
  OR?: AddressWhereInput | Enumerable<AddressWhereInput>
  NOT?: AddressWhereInput | Enumerable<AddressWhereInput>
  id?: IntFilter | number
  type?: StringFilter | string
  address?: StringFilter | string
  Student?: StudentRelationFilter | StudentWhereInput | null
  studentId?: IntNullableFilter | number | null
}

export type AddressOrderByInput = {
  id?: SortOrder
  type?: SortOrder
  address?: SortOrder
  studentId?: SortOrder
}

export type AddressWhereUniqueInput = {
  id?: number
}

export type PhoneNumberWhereInput = {
  AND?: PhoneNumberWhereInput | Enumerable<PhoneNumberWhereInput>
  OR?: PhoneNumberWhereInput | Enumerable<PhoneNumberWhereInput>
  NOT?: PhoneNumberWhereInput | Enumerable<PhoneNumberWhereInput>
  id?: IntFilter | number
  type?: StringFilter | string
  number?: StringFilter | string
  ext?: StringFilter | string
  country?: IntFilter | number
  preferred?: BoolFilter | boolean
  Student?: StudentRelationFilter | StudentWhereInput | null
  studentId?: IntNullableFilter | number | null
}

export type PhoneNumberOrderByInput = {
  id?: SortOrder
  type?: SortOrder
  number?: SortOrder
  ext?: SortOrder
  country?: SortOrder
  preferred?: SortOrder
  studentId?: SortOrder
}

export type PhoneNumberWhereUniqueInput = {
  id?: number
}

export type EmailAddressWhereInput = {
  AND?: EmailAddressWhereInput | Enumerable<EmailAddressWhereInput>
  OR?: EmailAddressWhereInput | Enumerable<EmailAddressWhereInput>
  NOT?: EmailAddressWhereInput | Enumerable<EmailAddressWhereInput>
  id?: IntFilter | number
  type?: StringFilter | string
  address?: StringFilter | string
  preferred?: BoolFilter | boolean
  Student?: StudentRelationFilter | StudentWhereInput | null
  studentId?: IntNullableFilter | number | null
}

export type EmailAddressOrderByInput = {
  id?: SortOrder
  type?: SortOrder
  address?: SortOrder
  preferred?: SortOrder
  studentId?: SortOrder
}

export type EmailAddressWhereUniqueInput = {
  id?: number
}

export type FinanceWhereInput = {
  AND?: FinanceWhereInput | Enumerable<FinanceWhereInput>
  OR?: FinanceWhereInput | Enumerable<FinanceWhereInput>
  NOT?: FinanceWhereInput | Enumerable<FinanceWhereInput>
  id?: IntFilter | number
  accountBalance?: FloatFilter | number
  Student?: StudentListRelationFilter
}

export type FinanceOrderByInput = {
  id?: SortOrder
  accountBalance?: SortOrder
}

export type FinanceWhereUniqueInput = {
  id?: number
}

export type AnnouncementWhereInput = {
  AND?: AnnouncementWhereInput | Enumerable<AnnouncementWhereInput>
  OR?: AnnouncementWhereInput | Enumerable<AnnouncementWhereInput>
  NOT?: AnnouncementWhereInput | Enumerable<AnnouncementWhereInput>
  id?: IntFilter | number
  title?: StringFilter | string
  detail?: StringFilter | string
  imageUrl?: StringFilter | string
}

export type AnnouncementOrderByInput = {
  id?: SortOrder
  title?: SortOrder
  detail?: SortOrder
  imageUrl?: SortOrder
}

export type AnnouncementWhereUniqueInput = {
  id?: number
}

export type ActionItemWhereInput = {
  AND?: ActionItemWhereInput | Enumerable<ActionItemWhereInput>
  OR?: ActionItemWhereInput | Enumerable<ActionItemWhereInput>
  NOT?: ActionItemWhereInput | Enumerable<ActionItemWhereInput>
  id?: IntFilter | number
  title?: StringFilter | string
  detail?: StringFilter | string
  completed?: BoolFilter | boolean
  Student?: StudentRelationFilter | StudentWhereInput | null
  studentId?: IntNullableFilter | number | null
}

export type ActionItemOrderByInput = {
  id?: SortOrder
  title?: SortOrder
  detail?: SortOrder
  completed?: SortOrder
  studentId?: SortOrder
}

export type ActionItemWhereUniqueInput = {
  id?: number
}

export type ContactWhereInput = {
  AND?: ContactWhereInput | Enumerable<ContactWhereInput>
  OR?: ContactWhereInput | Enumerable<ContactWhereInput>
  NOT?: ContactWhereInput | Enumerable<ContactWhereInput>
  id?: IntFilter | number
  primary?: BoolFilter | boolean
  name?: StringFilter | string
  relationship?: StringFilter | string
  number?: StringFilter | string
  ext?: IntFilter | number
  country?: StringFilter | string
  Student?: StudentRelationFilter | StudentWhereInput | null
  studentId?: IntNullableFilter | number | null
}

export type ContactOrderByInput = {
  id?: SortOrder
  primary?: SortOrder
  name?: SortOrder
  relationship?: SortOrder
  number?: SortOrder
  ext?: SortOrder
  country?: SortOrder
  studentId?: SortOrder
}

export type ContactWhereUniqueInput = {
  id?: number
}

export type ClassWhereInput = {
  AND?: ClassWhereInput | Enumerable<ClassWhereInput>
  OR?: ClassWhereInput | Enumerable<ClassWhereInput>
  NOT?: ClassWhereInput | Enumerable<ClassWhereInput>
  id?: IntFilter | number
  name?: StringFilter | string
  code?: StringFilter | string
  title?: StringFilter | string
  days?: StringFilter | string
  time?: StringFilter | string
  location?: StringFilter | string
  students?: StudentListRelationFilter
  Teacher?: TeacherRelationFilter | TeacherWhereInput | null
  teacherId?: IntNullableFilter | number | null
}

export type ClassOrderByInput = {
  id?: SortOrder
  name?: SortOrder
  code?: SortOrder
  title?: SortOrder
  days?: SortOrder
  time?: SortOrder
  location?: SortOrder
  teacherId?: SortOrder
}

export type ClassWhereUniqueInput = {
  id?: number
}

export type TeacherWhereInput = {
  AND?: TeacherWhereInput | Enumerable<TeacherWhereInput>
  OR?: TeacherWhereInput | Enumerable<TeacherWhereInput>
  NOT?: TeacherWhereInput | Enumerable<TeacherWhereInput>
  id?: IntFilter | number
  email?: StringFilter | string
  name?: StringFilter | string
  Class?: ClassListRelationFilter
  Student?: StudentListRelationFilter
}

export type TeacherOrderByInput = {
  id?: SortOrder
  email?: SortOrder
  name?: SortOrder
}

export type TeacherWhereUniqueInput = {
  id?: number
}

export type StudentCreateInput = {
  studentID: number
  profilePicURL: string
  creditsCompleted: number
  gender: string
  dob: string
  birthCountry: string
  birthState: string
  maritialStatus: string
  militaryStatus: string
  citizenshipStatus: string
  citizenshipCountry: string
  visaType: string
  visaPermit: string
  visaCountry: string
  names?: NameCreateManyWithoutStudentInput
  addresses?: AddressCreateManyWithoutStudentInput
  phonenumbers?: PhoneNumberCreateManyWithoutStudentInput
  emails?: EmailAddressCreateManyWithoutStudentInput
  contacts?: ContactCreateManyWithoutStudentInput
  finance?: FinanceCreateOneWithoutStudentInput
  actionItems?: ActionItemCreateManyWithoutStudentInput
  advisor?: TeacherCreateOneWithoutStudentInput
  classes?: ClassCreateManyWithoutStudentsInput
}

export type StudentUpdateInput = {
  studentID?: number | IntFieldUpdateOperationsInput
  profilePicURL?: string | StringFieldUpdateOperationsInput
  creditsCompleted?: number | IntFieldUpdateOperationsInput
  gender?: string | StringFieldUpdateOperationsInput
  dob?: string | StringFieldUpdateOperationsInput
  birthCountry?: string | StringFieldUpdateOperationsInput
  birthState?: string | StringFieldUpdateOperationsInput
  maritialStatus?: string | StringFieldUpdateOperationsInput
  militaryStatus?: string | StringFieldUpdateOperationsInput
  citizenshipStatus?: string | StringFieldUpdateOperationsInput
  citizenshipCountry?: string | StringFieldUpdateOperationsInput
  visaType?: string | StringFieldUpdateOperationsInput
  visaPermit?: string | StringFieldUpdateOperationsInput
  visaCountry?: string | StringFieldUpdateOperationsInput
  names?: NameUpdateManyWithoutStudentInput
  addresses?: AddressUpdateManyWithoutStudentInput
  phonenumbers?: PhoneNumberUpdateManyWithoutStudentInput
  emails?: EmailAddressUpdateManyWithoutStudentInput
  contacts?: ContactUpdateManyWithoutStudentInput
  finance?: FinanceUpdateOneWithoutStudentInput
  actionItems?: ActionItemUpdateManyWithoutStudentInput
  advisor?: TeacherUpdateOneWithoutStudentInput
  classes?: ClassUpdateManyWithoutStudentsInput
}

export type StudentUpdateManyMutationInput = {
  studentID?: number | IntFieldUpdateOperationsInput
  profilePicURL?: string | StringFieldUpdateOperationsInput
  creditsCompleted?: number | IntFieldUpdateOperationsInput
  gender?: string | StringFieldUpdateOperationsInput
  dob?: string | StringFieldUpdateOperationsInput
  birthCountry?: string | StringFieldUpdateOperationsInput
  birthState?: string | StringFieldUpdateOperationsInput
  maritialStatus?: string | StringFieldUpdateOperationsInput
  militaryStatus?: string | StringFieldUpdateOperationsInput
  citizenshipStatus?: string | StringFieldUpdateOperationsInput
  citizenshipCountry?: string | StringFieldUpdateOperationsInput
  visaType?: string | StringFieldUpdateOperationsInput
  visaPermit?: string | StringFieldUpdateOperationsInput
  visaCountry?: string | StringFieldUpdateOperationsInput
}

export type NameCreateInput = {
  name: string
  type: string
  Student?: StudentCreateOneWithoutNamesInput
}

export type NameUpdateInput = {
  name?: string | StringFieldUpdateOperationsInput
  type?: string | StringFieldUpdateOperationsInput
  Student?: StudentUpdateOneWithoutNamesInput
}

export type NameUpdateManyMutationInput = {
  name?: string | StringFieldUpdateOperationsInput
  type?: string | StringFieldUpdateOperationsInput
}

export type AddressCreateInput = {
  type: string
  address: string
  Student?: StudentCreateOneWithoutAddressesInput
}

export type AddressUpdateInput = {
  type?: string | StringFieldUpdateOperationsInput
  address?: string | StringFieldUpdateOperationsInput
  Student?: StudentUpdateOneWithoutAddressesInput
}

export type AddressUpdateManyMutationInput = {
  type?: string | StringFieldUpdateOperationsInput
  address?: string | StringFieldUpdateOperationsInput
}

export type PhoneNumberCreateInput = {
  type: string
  number: string
  ext: string
  country: number
  preferred: boolean
  Student?: StudentCreateOneWithoutPhonenumbersInput
}

export type PhoneNumberUpdateInput = {
  type?: string | StringFieldUpdateOperationsInput
  number?: string | StringFieldUpdateOperationsInput
  ext?: string | StringFieldUpdateOperationsInput
  country?: number | IntFieldUpdateOperationsInput
  preferred?: boolean | BoolFieldUpdateOperationsInput
  Student?: StudentUpdateOneWithoutPhonenumbersInput
}

export type PhoneNumberUpdateManyMutationInput = {
  type?: string | StringFieldUpdateOperationsInput
  number?: string | StringFieldUpdateOperationsInput
  ext?: string | StringFieldUpdateOperationsInput
  country?: number | IntFieldUpdateOperationsInput
  preferred?: boolean | BoolFieldUpdateOperationsInput
}

export type EmailAddressCreateInput = {
  type: string
  address: string
  preferred: boolean
  Student?: StudentCreateOneWithoutEmailsInput
}

export type EmailAddressUpdateInput = {
  type?: string | StringFieldUpdateOperationsInput
  address?: string | StringFieldUpdateOperationsInput
  preferred?: boolean | BoolFieldUpdateOperationsInput
  Student?: StudentUpdateOneWithoutEmailsInput
}

export type EmailAddressUpdateManyMutationInput = {
  type?: string | StringFieldUpdateOperationsInput
  address?: string | StringFieldUpdateOperationsInput
  preferred?: boolean | BoolFieldUpdateOperationsInput
}

export type FinanceCreateInput = {
  accountBalance: number
  Student?: StudentCreateManyWithoutFinanceInput
}

export type FinanceUpdateInput = {
  accountBalance?: number | FloatFieldUpdateOperationsInput
  Student?: StudentUpdateManyWithoutFinanceInput
}

export type FinanceUpdateManyMutationInput = {
  accountBalance?: number | FloatFieldUpdateOperationsInput
}

export type AnnouncementCreateInput = {
  title: string
  detail: string
  imageUrl: string
}

export type AnnouncementUpdateInput = {
  title?: string | StringFieldUpdateOperationsInput
  detail?: string | StringFieldUpdateOperationsInput
  imageUrl?: string | StringFieldUpdateOperationsInput
}

export type AnnouncementUpdateManyMutationInput = {
  title?: string | StringFieldUpdateOperationsInput
  detail?: string | StringFieldUpdateOperationsInput
  imageUrl?: string | StringFieldUpdateOperationsInput
}

export type ActionItemCreateInput = {
  title: string
  detail: string
  completed: boolean
  Student?: StudentCreateOneWithoutActionItemsInput
}

export type ActionItemUpdateInput = {
  title?: string | StringFieldUpdateOperationsInput
  detail?: string | StringFieldUpdateOperationsInput
  completed?: boolean | BoolFieldUpdateOperationsInput
  Student?: StudentUpdateOneWithoutActionItemsInput
}

export type ActionItemUpdateManyMutationInput = {
  title?: string | StringFieldUpdateOperationsInput
  detail?: string | StringFieldUpdateOperationsInput
  completed?: boolean | BoolFieldUpdateOperationsInput
}

export type ContactCreateInput = {
  primary: boolean
  name: string
  relationship: string
  number: string
  ext: number
  country: string
  Student?: StudentCreateOneWithoutContactsInput
}

export type ContactUpdateInput = {
  primary?: boolean | BoolFieldUpdateOperationsInput
  name?: string | StringFieldUpdateOperationsInput
  relationship?: string | StringFieldUpdateOperationsInput
  number?: string | StringFieldUpdateOperationsInput
  ext?: number | IntFieldUpdateOperationsInput
  country?: string | StringFieldUpdateOperationsInput
  Student?: StudentUpdateOneWithoutContactsInput
}

export type ContactUpdateManyMutationInput = {
  primary?: boolean | BoolFieldUpdateOperationsInput
  name?: string | StringFieldUpdateOperationsInput
  relationship?: string | StringFieldUpdateOperationsInput
  number?: string | StringFieldUpdateOperationsInput
  ext?: number | IntFieldUpdateOperationsInput
  country?: string | StringFieldUpdateOperationsInput
}

export type ClassCreateInput = {
  name: string
  code: string
  title: string
  days: string
  time: string
  location: string
  students?: StudentCreateManyWithoutClassesInput
  Teacher?: TeacherCreateOneWithoutClassInput
}

export type ClassUpdateInput = {
  name?: string | StringFieldUpdateOperationsInput
  code?: string | StringFieldUpdateOperationsInput
  title?: string | StringFieldUpdateOperationsInput
  days?: string | StringFieldUpdateOperationsInput
  time?: string | StringFieldUpdateOperationsInput
  location?: string | StringFieldUpdateOperationsInput
  students?: StudentUpdateManyWithoutClassesInput
  Teacher?: TeacherUpdateOneWithoutClassInput
}

export type ClassUpdateManyMutationInput = {
  name?: string | StringFieldUpdateOperationsInput
  code?: string | StringFieldUpdateOperationsInput
  title?: string | StringFieldUpdateOperationsInput
  days?: string | StringFieldUpdateOperationsInput
  time?: string | StringFieldUpdateOperationsInput
  location?: string | StringFieldUpdateOperationsInput
}

export type TeacherCreateInput = {
  email: string
  name: string
  Class?: ClassCreateManyWithoutTeacherInput
  Student?: StudentCreateManyWithoutAdvisorInput
}

export type TeacherUpdateInput = {
  email?: string | StringFieldUpdateOperationsInput
  name?: string | StringFieldUpdateOperationsInput
  Class?: ClassUpdateManyWithoutTeacherInput
  Student?: StudentUpdateManyWithoutAdvisorInput
}

export type TeacherUpdateManyMutationInput = {
  email?: string | StringFieldUpdateOperationsInput
  name?: string | StringFieldUpdateOperationsInput
}

export type IntFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntFilter
}

export type StringFilter = {
  equals?: string
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  not?: string | NestedStringFilter
}

export type NameListRelationFilter = {
  every?: NameWhereInput
  some?: NameWhereInput
  none?: NameWhereInput
}

export type AddressListRelationFilter = {
  every?: AddressWhereInput
  some?: AddressWhereInput
  none?: AddressWhereInput
}

export type PhoneNumberListRelationFilter = {
  every?: PhoneNumberWhereInput
  some?: PhoneNumberWhereInput
  none?: PhoneNumberWhereInput
}

export type EmailAddressListRelationFilter = {
  every?: EmailAddressWhereInput
  some?: EmailAddressWhereInput
  none?: EmailAddressWhereInput
}

export type ContactListRelationFilter = {
  every?: ContactWhereInput
  some?: ContactWhereInput
  none?: ContactWhereInput
}

export type FinanceRelationFilter = {
  is?: FinanceWhereInput | null
  isNot?: FinanceWhereInput | null
}

export type IntNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntNullableFilter | null
}

export type ActionItemListRelationFilter = {
  every?: ActionItemWhereInput
  some?: ActionItemWhereInput
  none?: ActionItemWhereInput
}

export type TeacherRelationFilter = {
  is?: TeacherWhereInput | null
  isNot?: TeacherWhereInput | null
}

export type ClassListRelationFilter = {
  every?: ClassWhereInput
  some?: ClassWhereInput
  none?: ClassWhereInput
}

export type StudentRelationFilter = {
  is?: StudentWhereInput | null
  isNot?: StudentWhereInput | null
}

export type BoolFilter = {
  equals?: boolean
  not?: boolean | NestedBoolFilter
}

export type FloatFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedFloatFilter
}

export type StudentListRelationFilter = {
  every?: StudentWhereInput
  some?: StudentWhereInput
  none?: StudentWhereInput
}

export type NameCreateManyWithoutStudentInput = {
  create?: NameCreateWithoutStudentInput | Enumerable<NameCreateWithoutStudentInput>
  connect?: NameWhereUniqueInput | Enumerable<NameWhereUniqueInput>
}

export type AddressCreateManyWithoutStudentInput = {
  create?: AddressCreateWithoutStudentInput | Enumerable<AddressCreateWithoutStudentInput>
  connect?: AddressWhereUniqueInput | Enumerable<AddressWhereUniqueInput>
}

export type PhoneNumberCreateManyWithoutStudentInput = {
  create?: PhoneNumberCreateWithoutStudentInput | Enumerable<PhoneNumberCreateWithoutStudentInput>
  connect?: PhoneNumberWhereUniqueInput | Enumerable<PhoneNumberWhereUniqueInput>
}

export type EmailAddressCreateManyWithoutStudentInput = {
  create?: EmailAddressCreateWithoutStudentInput | Enumerable<EmailAddressCreateWithoutStudentInput>
  connect?: EmailAddressWhereUniqueInput | Enumerable<EmailAddressWhereUniqueInput>
}

export type ContactCreateManyWithoutStudentInput = {
  create?: ContactCreateWithoutStudentInput | Enumerable<ContactCreateWithoutStudentInput>
  connect?: ContactWhereUniqueInput | Enumerable<ContactWhereUniqueInput>
}

export type FinanceCreateOneWithoutStudentInput = {
  create?: FinanceCreateWithoutStudentInput
  connect?: FinanceWhereUniqueInput
}

export type ActionItemCreateManyWithoutStudentInput = {
  create?: ActionItemCreateWithoutStudentInput | Enumerable<ActionItemCreateWithoutStudentInput>
  connect?: ActionItemWhereUniqueInput | Enumerable<ActionItemWhereUniqueInput>
}

export type TeacherCreateOneWithoutStudentInput = {
  create?: TeacherCreateWithoutStudentInput
  connect?: TeacherWhereUniqueInput
}

export type ClassCreateManyWithoutStudentsInput = {
  create?: ClassCreateWithoutStudentsInput | Enumerable<ClassCreateWithoutStudentsInput>
  connect?: ClassWhereUniqueInput | Enumerable<ClassWhereUniqueInput>
}

export type IntFieldUpdateOperationsInput = {
  set?: number
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type StringFieldUpdateOperationsInput = {
  set?: string
}

export type NameUpdateManyWithoutStudentInput = {
  create?: NameCreateWithoutStudentInput | Enumerable<NameCreateWithoutStudentInput>
  connect?: NameWhereUniqueInput | Enumerable<NameWhereUniqueInput>
  set?: NameWhereUniqueInput | Enumerable<NameWhereUniqueInput>
  disconnect?: NameWhereUniqueInput | Enumerable<NameWhereUniqueInput>
  delete?: NameWhereUniqueInput | Enumerable<NameWhereUniqueInput>
  update?: NameUpdateWithWhereUniqueWithoutStudentInput | Enumerable<NameUpdateWithWhereUniqueWithoutStudentInput>
  updateMany?: NameUpdateManyWithWhereNestedInput | Enumerable<NameUpdateManyWithWhereNestedInput>
  deleteMany?: NameScalarWhereInput | Enumerable<NameScalarWhereInput>
  upsert?: NameUpsertWithWhereUniqueWithoutStudentInput | Enumerable<NameUpsertWithWhereUniqueWithoutStudentInput>
}

export type AddressUpdateManyWithoutStudentInput = {
  create?: AddressCreateWithoutStudentInput | Enumerable<AddressCreateWithoutStudentInput>
  connect?: AddressWhereUniqueInput | Enumerable<AddressWhereUniqueInput>
  set?: AddressWhereUniqueInput | Enumerable<AddressWhereUniqueInput>
  disconnect?: AddressWhereUniqueInput | Enumerable<AddressWhereUniqueInput>
  delete?: AddressWhereUniqueInput | Enumerable<AddressWhereUniqueInput>
  update?: AddressUpdateWithWhereUniqueWithoutStudentInput | Enumerable<AddressUpdateWithWhereUniqueWithoutStudentInput>
  updateMany?: AddressUpdateManyWithWhereNestedInput | Enumerable<AddressUpdateManyWithWhereNestedInput>
  deleteMany?: AddressScalarWhereInput | Enumerable<AddressScalarWhereInput>
  upsert?: AddressUpsertWithWhereUniqueWithoutStudentInput | Enumerable<AddressUpsertWithWhereUniqueWithoutStudentInput>
}

export type PhoneNumberUpdateManyWithoutStudentInput = {
  create?: PhoneNumberCreateWithoutStudentInput | Enumerable<PhoneNumberCreateWithoutStudentInput>
  connect?: PhoneNumberWhereUniqueInput | Enumerable<PhoneNumberWhereUniqueInput>
  set?: PhoneNumberWhereUniqueInput | Enumerable<PhoneNumberWhereUniqueInput>
  disconnect?: PhoneNumberWhereUniqueInput | Enumerable<PhoneNumberWhereUniqueInput>
  delete?: PhoneNumberWhereUniqueInput | Enumerable<PhoneNumberWhereUniqueInput>
  update?: PhoneNumberUpdateWithWhereUniqueWithoutStudentInput | Enumerable<PhoneNumberUpdateWithWhereUniqueWithoutStudentInput>
  updateMany?: PhoneNumberUpdateManyWithWhereNestedInput | Enumerable<PhoneNumberUpdateManyWithWhereNestedInput>
  deleteMany?: PhoneNumberScalarWhereInput | Enumerable<PhoneNumberScalarWhereInput>
  upsert?: PhoneNumberUpsertWithWhereUniqueWithoutStudentInput | Enumerable<PhoneNumberUpsertWithWhereUniqueWithoutStudentInput>
}

export type EmailAddressUpdateManyWithoutStudentInput = {
  create?: EmailAddressCreateWithoutStudentInput | Enumerable<EmailAddressCreateWithoutStudentInput>
  connect?: EmailAddressWhereUniqueInput | Enumerable<EmailAddressWhereUniqueInput>
  set?: EmailAddressWhereUniqueInput | Enumerable<EmailAddressWhereUniqueInput>
  disconnect?: EmailAddressWhereUniqueInput | Enumerable<EmailAddressWhereUniqueInput>
  delete?: EmailAddressWhereUniqueInput | Enumerable<EmailAddressWhereUniqueInput>
  update?: EmailAddressUpdateWithWhereUniqueWithoutStudentInput | Enumerable<EmailAddressUpdateWithWhereUniqueWithoutStudentInput>
  updateMany?: EmailAddressUpdateManyWithWhereNestedInput | Enumerable<EmailAddressUpdateManyWithWhereNestedInput>
  deleteMany?: EmailAddressScalarWhereInput | Enumerable<EmailAddressScalarWhereInput>
  upsert?: EmailAddressUpsertWithWhereUniqueWithoutStudentInput | Enumerable<EmailAddressUpsertWithWhereUniqueWithoutStudentInput>
}

export type ContactUpdateManyWithoutStudentInput = {
  create?: ContactCreateWithoutStudentInput | Enumerable<ContactCreateWithoutStudentInput>
  connect?: ContactWhereUniqueInput | Enumerable<ContactWhereUniqueInput>
  set?: ContactWhereUniqueInput | Enumerable<ContactWhereUniqueInput>
  disconnect?: ContactWhereUniqueInput | Enumerable<ContactWhereUniqueInput>
  delete?: ContactWhereUniqueInput | Enumerable<ContactWhereUniqueInput>
  update?: ContactUpdateWithWhereUniqueWithoutStudentInput | Enumerable<ContactUpdateWithWhereUniqueWithoutStudentInput>
  updateMany?: ContactUpdateManyWithWhereNestedInput | Enumerable<ContactUpdateManyWithWhereNestedInput>
  deleteMany?: ContactScalarWhereInput | Enumerable<ContactScalarWhereInput>
  upsert?: ContactUpsertWithWhereUniqueWithoutStudentInput | Enumerable<ContactUpsertWithWhereUniqueWithoutStudentInput>
}

export type FinanceUpdateOneWithoutStudentInput = {
  create?: FinanceCreateWithoutStudentInput
  connect?: FinanceWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: FinanceUpdateWithoutStudentDataInput
  upsert?: FinanceUpsertWithoutStudentInput
}

export type ActionItemUpdateManyWithoutStudentInput = {
  create?: ActionItemCreateWithoutStudentInput | Enumerable<ActionItemCreateWithoutStudentInput>
  connect?: ActionItemWhereUniqueInput | Enumerable<ActionItemWhereUniqueInput>
  set?: ActionItemWhereUniqueInput | Enumerable<ActionItemWhereUniqueInput>
  disconnect?: ActionItemWhereUniqueInput | Enumerable<ActionItemWhereUniqueInput>
  delete?: ActionItemWhereUniqueInput | Enumerable<ActionItemWhereUniqueInput>
  update?: ActionItemUpdateWithWhereUniqueWithoutStudentInput | Enumerable<ActionItemUpdateWithWhereUniqueWithoutStudentInput>
  updateMany?: ActionItemUpdateManyWithWhereNestedInput | Enumerable<ActionItemUpdateManyWithWhereNestedInput>
  deleteMany?: ActionItemScalarWhereInput | Enumerable<ActionItemScalarWhereInput>
  upsert?: ActionItemUpsertWithWhereUniqueWithoutStudentInput | Enumerable<ActionItemUpsertWithWhereUniqueWithoutStudentInput>
}

export type TeacherUpdateOneWithoutStudentInput = {
  create?: TeacherCreateWithoutStudentInput
  connect?: TeacherWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: TeacherUpdateWithoutStudentDataInput
  upsert?: TeacherUpsertWithoutStudentInput
}

export type ClassUpdateManyWithoutStudentsInput = {
  create?: ClassCreateWithoutStudentsInput | Enumerable<ClassCreateWithoutStudentsInput>
  connect?: ClassWhereUniqueInput | Enumerable<ClassWhereUniqueInput>
  set?: ClassWhereUniqueInput | Enumerable<ClassWhereUniqueInput>
  disconnect?: ClassWhereUniqueInput | Enumerable<ClassWhereUniqueInput>
  delete?: ClassWhereUniqueInput | Enumerable<ClassWhereUniqueInput>
  update?: ClassUpdateWithWhereUniqueWithoutStudentsInput | Enumerable<ClassUpdateWithWhereUniqueWithoutStudentsInput>
  updateMany?: ClassUpdateManyWithWhereNestedInput | Enumerable<ClassUpdateManyWithWhereNestedInput>
  deleteMany?: ClassScalarWhereInput | Enumerable<ClassScalarWhereInput>
  upsert?: ClassUpsertWithWhereUniqueWithoutStudentsInput | Enumerable<ClassUpsertWithWhereUniqueWithoutStudentsInput>
}

export type StudentCreateOneWithoutNamesInput = {
  create?: StudentCreateWithoutNamesInput
  connect?: StudentWhereUniqueInput
}

export type StudentUpdateOneWithoutNamesInput = {
  create?: StudentCreateWithoutNamesInput
  connect?: StudentWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: StudentUpdateWithoutNamesDataInput
  upsert?: StudentUpsertWithoutNamesInput
}

export type StudentCreateOneWithoutAddressesInput = {
  create?: StudentCreateWithoutAddressesInput
  connect?: StudentWhereUniqueInput
}

export type StudentUpdateOneWithoutAddressesInput = {
  create?: StudentCreateWithoutAddressesInput
  connect?: StudentWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: StudentUpdateWithoutAddressesDataInput
  upsert?: StudentUpsertWithoutAddressesInput
}

export type StudentCreateOneWithoutPhonenumbersInput = {
  create?: StudentCreateWithoutPhonenumbersInput
  connect?: StudentWhereUniqueInput
}

export type BoolFieldUpdateOperationsInput = {
  set?: boolean
}

export type StudentUpdateOneWithoutPhonenumbersInput = {
  create?: StudentCreateWithoutPhonenumbersInput
  connect?: StudentWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: StudentUpdateWithoutPhonenumbersDataInput
  upsert?: StudentUpsertWithoutPhonenumbersInput
}

export type StudentCreateOneWithoutEmailsInput = {
  create?: StudentCreateWithoutEmailsInput
  connect?: StudentWhereUniqueInput
}

export type StudentUpdateOneWithoutEmailsInput = {
  create?: StudentCreateWithoutEmailsInput
  connect?: StudentWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: StudentUpdateWithoutEmailsDataInput
  upsert?: StudentUpsertWithoutEmailsInput
}

export type StudentCreateManyWithoutFinanceInput = {
  create?: StudentCreateWithoutFinanceInput | Enumerable<StudentCreateWithoutFinanceInput>
  connect?: StudentWhereUniqueInput | Enumerable<StudentWhereUniqueInput>
}

export type FloatFieldUpdateOperationsInput = {
  set?: number
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type StudentUpdateManyWithoutFinanceInput = {
  create?: StudentCreateWithoutFinanceInput | Enumerable<StudentCreateWithoutFinanceInput>
  connect?: StudentWhereUniqueInput | Enumerable<StudentWhereUniqueInput>
  set?: StudentWhereUniqueInput | Enumerable<StudentWhereUniqueInput>
  disconnect?: StudentWhereUniqueInput | Enumerable<StudentWhereUniqueInput>
  delete?: StudentWhereUniqueInput | Enumerable<StudentWhereUniqueInput>
  update?: StudentUpdateWithWhereUniqueWithoutFinanceInput | Enumerable<StudentUpdateWithWhereUniqueWithoutFinanceInput>
  updateMany?: StudentUpdateManyWithWhereNestedInput | Enumerable<StudentUpdateManyWithWhereNestedInput>
  deleteMany?: StudentScalarWhereInput | Enumerable<StudentScalarWhereInput>
  upsert?: StudentUpsertWithWhereUniqueWithoutFinanceInput | Enumerable<StudentUpsertWithWhereUniqueWithoutFinanceInput>
}

export type StudentCreateOneWithoutActionItemsInput = {
  create?: StudentCreateWithoutActionItemsInput
  connect?: StudentWhereUniqueInput
}

export type StudentUpdateOneWithoutActionItemsInput = {
  create?: StudentCreateWithoutActionItemsInput
  connect?: StudentWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: StudentUpdateWithoutActionItemsDataInput
  upsert?: StudentUpsertWithoutActionItemsInput
}

export type StudentCreateOneWithoutContactsInput = {
  create?: StudentCreateWithoutContactsInput
  connect?: StudentWhereUniqueInput
}

export type StudentUpdateOneWithoutContactsInput = {
  create?: StudentCreateWithoutContactsInput
  connect?: StudentWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: StudentUpdateWithoutContactsDataInput
  upsert?: StudentUpsertWithoutContactsInput
}

export type StudentCreateManyWithoutClassesInput = {
  create?: StudentCreateWithoutClassesInput | Enumerable<StudentCreateWithoutClassesInput>
  connect?: StudentWhereUniqueInput | Enumerable<StudentWhereUniqueInput>
}

export type TeacherCreateOneWithoutClassInput = {
  create?: TeacherCreateWithoutClassInput
  connect?: TeacherWhereUniqueInput
}

export type StudentUpdateManyWithoutClassesInput = {
  create?: StudentCreateWithoutClassesInput | Enumerable<StudentCreateWithoutClassesInput>
  connect?: StudentWhereUniqueInput | Enumerable<StudentWhereUniqueInput>
  set?: StudentWhereUniqueInput | Enumerable<StudentWhereUniqueInput>
  disconnect?: StudentWhereUniqueInput | Enumerable<StudentWhereUniqueInput>
  delete?: StudentWhereUniqueInput | Enumerable<StudentWhereUniqueInput>
  update?: StudentUpdateWithWhereUniqueWithoutClassesInput | Enumerable<StudentUpdateWithWhereUniqueWithoutClassesInput>
  updateMany?: StudentUpdateManyWithWhereNestedInput | Enumerable<StudentUpdateManyWithWhereNestedInput>
  deleteMany?: StudentScalarWhereInput | Enumerable<StudentScalarWhereInput>
  upsert?: StudentUpsertWithWhereUniqueWithoutClassesInput | Enumerable<StudentUpsertWithWhereUniqueWithoutClassesInput>
}

export type TeacherUpdateOneWithoutClassInput = {
  create?: TeacherCreateWithoutClassInput
  connect?: TeacherWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: TeacherUpdateWithoutClassDataInput
  upsert?: TeacherUpsertWithoutClassInput
}

export type ClassCreateManyWithoutTeacherInput = {
  create?: ClassCreateWithoutTeacherInput | Enumerable<ClassCreateWithoutTeacherInput>
  connect?: ClassWhereUniqueInput | Enumerable<ClassWhereUniqueInput>
}

export type StudentCreateManyWithoutAdvisorInput = {
  create?: StudentCreateWithoutAdvisorInput | Enumerable<StudentCreateWithoutAdvisorInput>
  connect?: StudentWhereUniqueInput | Enumerable<StudentWhereUniqueInput>
}

export type ClassUpdateManyWithoutTeacherInput = {
  create?: ClassCreateWithoutTeacherInput | Enumerable<ClassCreateWithoutTeacherInput>
  connect?: ClassWhereUniqueInput | Enumerable<ClassWhereUniqueInput>
  set?: ClassWhereUniqueInput | Enumerable<ClassWhereUniqueInput>
  disconnect?: ClassWhereUniqueInput | Enumerable<ClassWhereUniqueInput>
  delete?: ClassWhereUniqueInput | Enumerable<ClassWhereUniqueInput>
  update?: ClassUpdateWithWhereUniqueWithoutTeacherInput | Enumerable<ClassUpdateWithWhereUniqueWithoutTeacherInput>
  updateMany?: ClassUpdateManyWithWhereNestedInput | Enumerable<ClassUpdateManyWithWhereNestedInput>
  deleteMany?: ClassScalarWhereInput | Enumerable<ClassScalarWhereInput>
  upsert?: ClassUpsertWithWhereUniqueWithoutTeacherInput | Enumerable<ClassUpsertWithWhereUniqueWithoutTeacherInput>
}

export type StudentUpdateManyWithoutAdvisorInput = {
  create?: StudentCreateWithoutAdvisorInput | Enumerable<StudentCreateWithoutAdvisorInput>
  connect?: StudentWhereUniqueInput | Enumerable<StudentWhereUniqueInput>
  set?: StudentWhereUniqueInput | Enumerable<StudentWhereUniqueInput>
  disconnect?: StudentWhereUniqueInput | Enumerable<StudentWhereUniqueInput>
  delete?: StudentWhereUniqueInput | Enumerable<StudentWhereUniqueInput>
  update?: StudentUpdateWithWhereUniqueWithoutAdvisorInput | Enumerable<StudentUpdateWithWhereUniqueWithoutAdvisorInput>
  updateMany?: StudentUpdateManyWithWhereNestedInput | Enumerable<StudentUpdateManyWithWhereNestedInput>
  deleteMany?: StudentScalarWhereInput | Enumerable<StudentScalarWhereInput>
  upsert?: StudentUpsertWithWhereUniqueWithoutAdvisorInput | Enumerable<StudentUpsertWithWhereUniqueWithoutAdvisorInput>
}

export type NestedIntFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntFilter
}

export type NestedStringFilter = {
  equals?: string
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  not?: string | NestedStringFilter
}

export type NestedIntNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntNullableFilter | null
}

export type NestedBoolFilter = {
  equals?: boolean
  not?: boolean | NestedBoolFilter
}

export type NestedFloatFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedFloatFilter
}

export type NameCreateWithoutStudentInput = {
  name: string
  type: string
}

export type AddressCreateWithoutStudentInput = {
  type: string
  address: string
}

export type PhoneNumberCreateWithoutStudentInput = {
  type: string
  number: string
  ext: string
  country: number
  preferred: boolean
}

export type EmailAddressCreateWithoutStudentInput = {
  type: string
  address: string
  preferred: boolean
}

export type ContactCreateWithoutStudentInput = {
  primary: boolean
  name: string
  relationship: string
  number: string
  ext: number
  country: string
}

export type FinanceCreateWithoutStudentInput = {
  accountBalance: number
}

export type ActionItemCreateWithoutStudentInput = {
  title: string
  detail: string
  completed: boolean
}

export type TeacherCreateWithoutStudentInput = {
  email: string
  name: string
  Class?: ClassCreateManyWithoutTeacherInput
}

export type ClassCreateWithoutStudentsInput = {
  name: string
  code: string
  title: string
  days: string
  time: string
  location: string
  Teacher?: TeacherCreateOneWithoutClassInput
}

export type NameUpdateWithWhereUniqueWithoutStudentInput = {
  where: NameWhereUniqueInput
  data: NameUpdateWithoutStudentDataInput
}

export type NameUpdateManyWithWhereNestedInput = {
  where: NameScalarWhereInput
  data: NameUpdateManyDataInput
}

export type NameScalarWhereInput = {
  AND?: NameScalarWhereInput | Enumerable<NameScalarWhereInput>
  OR?: NameScalarWhereInput | Enumerable<NameScalarWhereInput>
  NOT?: NameScalarWhereInput | Enumerable<NameScalarWhereInput>
  id?: IntFilter | number
  name?: StringFilter | string
  type?: StringFilter | string
  studentId?: IntNullableFilter | number | null
}

export type NameUpsertWithWhereUniqueWithoutStudentInput = {
  where: NameWhereUniqueInput
  update: NameUpdateWithoutStudentDataInput
  create: NameCreateWithoutStudentInput
}

export type AddressUpdateWithWhereUniqueWithoutStudentInput = {
  where: AddressWhereUniqueInput
  data: AddressUpdateWithoutStudentDataInput
}

export type AddressUpdateManyWithWhereNestedInput = {
  where: AddressScalarWhereInput
  data: AddressUpdateManyDataInput
}

export type AddressScalarWhereInput = {
  AND?: AddressScalarWhereInput | Enumerable<AddressScalarWhereInput>
  OR?: AddressScalarWhereInput | Enumerable<AddressScalarWhereInput>
  NOT?: AddressScalarWhereInput | Enumerable<AddressScalarWhereInput>
  id?: IntFilter | number
  type?: StringFilter | string
  address?: StringFilter | string
  studentId?: IntNullableFilter | number | null
}

export type AddressUpsertWithWhereUniqueWithoutStudentInput = {
  where: AddressWhereUniqueInput
  update: AddressUpdateWithoutStudentDataInput
  create: AddressCreateWithoutStudentInput
}

export type PhoneNumberUpdateWithWhereUniqueWithoutStudentInput = {
  where: PhoneNumberWhereUniqueInput
  data: PhoneNumberUpdateWithoutStudentDataInput
}

export type PhoneNumberUpdateManyWithWhereNestedInput = {
  where: PhoneNumberScalarWhereInput
  data: PhoneNumberUpdateManyDataInput
}

export type PhoneNumberScalarWhereInput = {
  AND?: PhoneNumberScalarWhereInput | Enumerable<PhoneNumberScalarWhereInput>
  OR?: PhoneNumberScalarWhereInput | Enumerable<PhoneNumberScalarWhereInput>
  NOT?: PhoneNumberScalarWhereInput | Enumerable<PhoneNumberScalarWhereInput>
  id?: IntFilter | number
  type?: StringFilter | string
  number?: StringFilter | string
  ext?: StringFilter | string
  country?: IntFilter | number
  preferred?: BoolFilter | boolean
  studentId?: IntNullableFilter | number | null
}

export type PhoneNumberUpsertWithWhereUniqueWithoutStudentInput = {
  where: PhoneNumberWhereUniqueInput
  update: PhoneNumberUpdateWithoutStudentDataInput
  create: PhoneNumberCreateWithoutStudentInput
}

export type EmailAddressUpdateWithWhereUniqueWithoutStudentInput = {
  where: EmailAddressWhereUniqueInput
  data: EmailAddressUpdateWithoutStudentDataInput
}

export type EmailAddressUpdateManyWithWhereNestedInput = {
  where: EmailAddressScalarWhereInput
  data: EmailAddressUpdateManyDataInput
}

export type EmailAddressScalarWhereInput = {
  AND?: EmailAddressScalarWhereInput | Enumerable<EmailAddressScalarWhereInput>
  OR?: EmailAddressScalarWhereInput | Enumerable<EmailAddressScalarWhereInput>
  NOT?: EmailAddressScalarWhereInput | Enumerable<EmailAddressScalarWhereInput>
  id?: IntFilter | number
  type?: StringFilter | string
  address?: StringFilter | string
  preferred?: BoolFilter | boolean
  studentId?: IntNullableFilter | number | null
}

export type EmailAddressUpsertWithWhereUniqueWithoutStudentInput = {
  where: EmailAddressWhereUniqueInput
  update: EmailAddressUpdateWithoutStudentDataInput
  create: EmailAddressCreateWithoutStudentInput
}

export type ContactUpdateWithWhereUniqueWithoutStudentInput = {
  where: ContactWhereUniqueInput
  data: ContactUpdateWithoutStudentDataInput
}

export type ContactUpdateManyWithWhereNestedInput = {
  where: ContactScalarWhereInput
  data: ContactUpdateManyDataInput
}

export type ContactScalarWhereInput = {
  AND?: ContactScalarWhereInput | Enumerable<ContactScalarWhereInput>
  OR?: ContactScalarWhereInput | Enumerable<ContactScalarWhereInput>
  NOT?: ContactScalarWhereInput | Enumerable<ContactScalarWhereInput>
  id?: IntFilter | number
  primary?: BoolFilter | boolean
  name?: StringFilter | string
  relationship?: StringFilter | string
  number?: StringFilter | string
  ext?: IntFilter | number
  country?: StringFilter | string
  studentId?: IntNullableFilter | number | null
}

export type ContactUpsertWithWhereUniqueWithoutStudentInput = {
  where: ContactWhereUniqueInput
  update: ContactUpdateWithoutStudentDataInput
  create: ContactCreateWithoutStudentInput
}

export type FinanceUpdateWithoutStudentDataInput = {
  accountBalance?: number | FloatFieldUpdateOperationsInput
}

export type FinanceUpsertWithoutStudentInput = {
  update: FinanceUpdateWithoutStudentDataInput
  create: FinanceCreateWithoutStudentInput
}

export type ActionItemUpdateWithWhereUniqueWithoutStudentInput = {
  where: ActionItemWhereUniqueInput
  data: ActionItemUpdateWithoutStudentDataInput
}

export type ActionItemUpdateManyWithWhereNestedInput = {
  where: ActionItemScalarWhereInput
  data: ActionItemUpdateManyDataInput
}

export type ActionItemScalarWhereInput = {
  AND?: ActionItemScalarWhereInput | Enumerable<ActionItemScalarWhereInput>
  OR?: ActionItemScalarWhereInput | Enumerable<ActionItemScalarWhereInput>
  NOT?: ActionItemScalarWhereInput | Enumerable<ActionItemScalarWhereInput>
  id?: IntFilter | number
  title?: StringFilter | string
  detail?: StringFilter | string
  completed?: BoolFilter | boolean
  studentId?: IntNullableFilter | number | null
}

export type ActionItemUpsertWithWhereUniqueWithoutStudentInput = {
  where: ActionItemWhereUniqueInput
  update: ActionItemUpdateWithoutStudentDataInput
  create: ActionItemCreateWithoutStudentInput
}

export type TeacherUpdateWithoutStudentDataInput = {
  email?: string | StringFieldUpdateOperationsInput
  name?: string | StringFieldUpdateOperationsInput
  Class?: ClassUpdateManyWithoutTeacherInput
}

export type TeacherUpsertWithoutStudentInput = {
  update: TeacherUpdateWithoutStudentDataInput
  create: TeacherCreateWithoutStudentInput
}

export type ClassUpdateWithWhereUniqueWithoutStudentsInput = {
  where: ClassWhereUniqueInput
  data: ClassUpdateWithoutStudentsDataInput
}

export type ClassUpdateManyWithWhereNestedInput = {
  where: ClassScalarWhereInput
  data: ClassUpdateManyDataInput
}

export type ClassScalarWhereInput = {
  AND?: ClassScalarWhereInput | Enumerable<ClassScalarWhereInput>
  OR?: ClassScalarWhereInput | Enumerable<ClassScalarWhereInput>
  NOT?: ClassScalarWhereInput | Enumerable<ClassScalarWhereInput>
  id?: IntFilter | number
  name?: StringFilter | string
  code?: StringFilter | string
  title?: StringFilter | string
  days?: StringFilter | string
  time?: StringFilter | string
  location?: StringFilter | string
  teacherId?: IntNullableFilter | number | null
}

export type ClassUpsertWithWhereUniqueWithoutStudentsInput = {
  where: ClassWhereUniqueInput
  update: ClassUpdateWithoutStudentsDataInput
  create: ClassCreateWithoutStudentsInput
}

export type StudentCreateWithoutNamesInput = {
  studentID: number
  profilePicURL: string
  creditsCompleted: number
  gender: string
  dob: string
  birthCountry: string
  birthState: string
  maritialStatus: string
  militaryStatus: string
  citizenshipStatus: string
  citizenshipCountry: string
  visaType: string
  visaPermit: string
  visaCountry: string
  addresses?: AddressCreateManyWithoutStudentInput
  phonenumbers?: PhoneNumberCreateManyWithoutStudentInput
  emails?: EmailAddressCreateManyWithoutStudentInput
  contacts?: ContactCreateManyWithoutStudentInput
  finance?: FinanceCreateOneWithoutStudentInput
  actionItems?: ActionItemCreateManyWithoutStudentInput
  advisor?: TeacherCreateOneWithoutStudentInput
  classes?: ClassCreateManyWithoutStudentsInput
}

export type StudentUpdateWithoutNamesDataInput = {
  studentID?: number | IntFieldUpdateOperationsInput
  profilePicURL?: string | StringFieldUpdateOperationsInput
  creditsCompleted?: number | IntFieldUpdateOperationsInput
  gender?: string | StringFieldUpdateOperationsInput
  dob?: string | StringFieldUpdateOperationsInput
  birthCountry?: string | StringFieldUpdateOperationsInput
  birthState?: string | StringFieldUpdateOperationsInput
  maritialStatus?: string | StringFieldUpdateOperationsInput
  militaryStatus?: string | StringFieldUpdateOperationsInput
  citizenshipStatus?: string | StringFieldUpdateOperationsInput
  citizenshipCountry?: string | StringFieldUpdateOperationsInput
  visaType?: string | StringFieldUpdateOperationsInput
  visaPermit?: string | StringFieldUpdateOperationsInput
  visaCountry?: string | StringFieldUpdateOperationsInput
  addresses?: AddressUpdateManyWithoutStudentInput
  phonenumbers?: PhoneNumberUpdateManyWithoutStudentInput
  emails?: EmailAddressUpdateManyWithoutStudentInput
  contacts?: ContactUpdateManyWithoutStudentInput
  finance?: FinanceUpdateOneWithoutStudentInput
  actionItems?: ActionItemUpdateManyWithoutStudentInput
  advisor?: TeacherUpdateOneWithoutStudentInput
  classes?: ClassUpdateManyWithoutStudentsInput
}

export type StudentUpsertWithoutNamesInput = {
  update: StudentUpdateWithoutNamesDataInput
  create: StudentCreateWithoutNamesInput
}

export type StudentCreateWithoutAddressesInput = {
  studentID: number
  profilePicURL: string
  creditsCompleted: number
  gender: string
  dob: string
  birthCountry: string
  birthState: string
  maritialStatus: string
  militaryStatus: string
  citizenshipStatus: string
  citizenshipCountry: string
  visaType: string
  visaPermit: string
  visaCountry: string
  names?: NameCreateManyWithoutStudentInput
  phonenumbers?: PhoneNumberCreateManyWithoutStudentInput
  emails?: EmailAddressCreateManyWithoutStudentInput
  contacts?: ContactCreateManyWithoutStudentInput
  finance?: FinanceCreateOneWithoutStudentInput
  actionItems?: ActionItemCreateManyWithoutStudentInput
  advisor?: TeacherCreateOneWithoutStudentInput
  classes?: ClassCreateManyWithoutStudentsInput
}

export type StudentUpdateWithoutAddressesDataInput = {
  studentID?: number | IntFieldUpdateOperationsInput
  profilePicURL?: string | StringFieldUpdateOperationsInput
  creditsCompleted?: number | IntFieldUpdateOperationsInput
  gender?: string | StringFieldUpdateOperationsInput
  dob?: string | StringFieldUpdateOperationsInput
  birthCountry?: string | StringFieldUpdateOperationsInput
  birthState?: string | StringFieldUpdateOperationsInput
  maritialStatus?: string | StringFieldUpdateOperationsInput
  militaryStatus?: string | StringFieldUpdateOperationsInput
  citizenshipStatus?: string | StringFieldUpdateOperationsInput
  citizenshipCountry?: string | StringFieldUpdateOperationsInput
  visaType?: string | StringFieldUpdateOperationsInput
  visaPermit?: string | StringFieldUpdateOperationsInput
  visaCountry?: string | StringFieldUpdateOperationsInput
  names?: NameUpdateManyWithoutStudentInput
  phonenumbers?: PhoneNumberUpdateManyWithoutStudentInput
  emails?: EmailAddressUpdateManyWithoutStudentInput
  contacts?: ContactUpdateManyWithoutStudentInput
  finance?: FinanceUpdateOneWithoutStudentInput
  actionItems?: ActionItemUpdateManyWithoutStudentInput
  advisor?: TeacherUpdateOneWithoutStudentInput
  classes?: ClassUpdateManyWithoutStudentsInput
}

export type StudentUpsertWithoutAddressesInput = {
  update: StudentUpdateWithoutAddressesDataInput
  create: StudentCreateWithoutAddressesInput
}

export type StudentCreateWithoutPhonenumbersInput = {
  studentID: number
  profilePicURL: string
  creditsCompleted: number
  gender: string
  dob: string
  birthCountry: string
  birthState: string
  maritialStatus: string
  militaryStatus: string
  citizenshipStatus: string
  citizenshipCountry: string
  visaType: string
  visaPermit: string
  visaCountry: string
  names?: NameCreateManyWithoutStudentInput
  addresses?: AddressCreateManyWithoutStudentInput
  emails?: EmailAddressCreateManyWithoutStudentInput
  contacts?: ContactCreateManyWithoutStudentInput
  finance?: FinanceCreateOneWithoutStudentInput
  actionItems?: ActionItemCreateManyWithoutStudentInput
  advisor?: TeacherCreateOneWithoutStudentInput
  classes?: ClassCreateManyWithoutStudentsInput
}

export type StudentUpdateWithoutPhonenumbersDataInput = {
  studentID?: number | IntFieldUpdateOperationsInput
  profilePicURL?: string | StringFieldUpdateOperationsInput
  creditsCompleted?: number | IntFieldUpdateOperationsInput
  gender?: string | StringFieldUpdateOperationsInput
  dob?: string | StringFieldUpdateOperationsInput
  birthCountry?: string | StringFieldUpdateOperationsInput
  birthState?: string | StringFieldUpdateOperationsInput
  maritialStatus?: string | StringFieldUpdateOperationsInput
  militaryStatus?: string | StringFieldUpdateOperationsInput
  citizenshipStatus?: string | StringFieldUpdateOperationsInput
  citizenshipCountry?: string | StringFieldUpdateOperationsInput
  visaType?: string | StringFieldUpdateOperationsInput
  visaPermit?: string | StringFieldUpdateOperationsInput
  visaCountry?: string | StringFieldUpdateOperationsInput
  names?: NameUpdateManyWithoutStudentInput
  addresses?: AddressUpdateManyWithoutStudentInput
  emails?: EmailAddressUpdateManyWithoutStudentInput
  contacts?: ContactUpdateManyWithoutStudentInput
  finance?: FinanceUpdateOneWithoutStudentInput
  actionItems?: ActionItemUpdateManyWithoutStudentInput
  advisor?: TeacherUpdateOneWithoutStudentInput
  classes?: ClassUpdateManyWithoutStudentsInput
}

export type StudentUpsertWithoutPhonenumbersInput = {
  update: StudentUpdateWithoutPhonenumbersDataInput
  create: StudentCreateWithoutPhonenumbersInput
}

export type StudentCreateWithoutEmailsInput = {
  studentID: number
  profilePicURL: string
  creditsCompleted: number
  gender: string
  dob: string
  birthCountry: string
  birthState: string
  maritialStatus: string
  militaryStatus: string
  citizenshipStatus: string
  citizenshipCountry: string
  visaType: string
  visaPermit: string
  visaCountry: string
  names?: NameCreateManyWithoutStudentInput
  addresses?: AddressCreateManyWithoutStudentInput
  phonenumbers?: PhoneNumberCreateManyWithoutStudentInput
  contacts?: ContactCreateManyWithoutStudentInput
  finance?: FinanceCreateOneWithoutStudentInput
  actionItems?: ActionItemCreateManyWithoutStudentInput
  advisor?: TeacherCreateOneWithoutStudentInput
  classes?: ClassCreateManyWithoutStudentsInput
}

export type StudentUpdateWithoutEmailsDataInput = {
  studentID?: number | IntFieldUpdateOperationsInput
  profilePicURL?: string | StringFieldUpdateOperationsInput
  creditsCompleted?: number | IntFieldUpdateOperationsInput
  gender?: string | StringFieldUpdateOperationsInput
  dob?: string | StringFieldUpdateOperationsInput
  birthCountry?: string | StringFieldUpdateOperationsInput
  birthState?: string | StringFieldUpdateOperationsInput
  maritialStatus?: string | StringFieldUpdateOperationsInput
  militaryStatus?: string | StringFieldUpdateOperationsInput
  citizenshipStatus?: string | StringFieldUpdateOperationsInput
  citizenshipCountry?: string | StringFieldUpdateOperationsInput
  visaType?: string | StringFieldUpdateOperationsInput
  visaPermit?: string | StringFieldUpdateOperationsInput
  visaCountry?: string | StringFieldUpdateOperationsInput
  names?: NameUpdateManyWithoutStudentInput
  addresses?: AddressUpdateManyWithoutStudentInput
  phonenumbers?: PhoneNumberUpdateManyWithoutStudentInput
  contacts?: ContactUpdateManyWithoutStudentInput
  finance?: FinanceUpdateOneWithoutStudentInput
  actionItems?: ActionItemUpdateManyWithoutStudentInput
  advisor?: TeacherUpdateOneWithoutStudentInput
  classes?: ClassUpdateManyWithoutStudentsInput
}

export type StudentUpsertWithoutEmailsInput = {
  update: StudentUpdateWithoutEmailsDataInput
  create: StudentCreateWithoutEmailsInput
}

export type StudentCreateWithoutFinanceInput = {
  studentID: number
  profilePicURL: string
  creditsCompleted: number
  gender: string
  dob: string
  birthCountry: string
  birthState: string
  maritialStatus: string
  militaryStatus: string
  citizenshipStatus: string
  citizenshipCountry: string
  visaType: string
  visaPermit: string
  visaCountry: string
  names?: NameCreateManyWithoutStudentInput
  addresses?: AddressCreateManyWithoutStudentInput
  phonenumbers?: PhoneNumberCreateManyWithoutStudentInput
  emails?: EmailAddressCreateManyWithoutStudentInput
  contacts?: ContactCreateManyWithoutStudentInput
  actionItems?: ActionItemCreateManyWithoutStudentInput
  advisor?: TeacherCreateOneWithoutStudentInput
  classes?: ClassCreateManyWithoutStudentsInput
}

export type StudentUpdateWithWhereUniqueWithoutFinanceInput = {
  where: StudentWhereUniqueInput
  data: StudentUpdateWithoutFinanceDataInput
}

export type StudentUpdateManyWithWhereNestedInput = {
  where: StudentScalarWhereInput
  data: StudentUpdateManyDataInput
}

export type StudentScalarWhereInput = {
  AND?: StudentScalarWhereInput | Enumerable<StudentScalarWhereInput>
  OR?: StudentScalarWhereInput | Enumerable<StudentScalarWhereInput>
  NOT?: StudentScalarWhereInput | Enumerable<StudentScalarWhereInput>
  id?: IntFilter | number
  studentID?: IntFilter | number
  profilePicURL?: StringFilter | string
  creditsCompleted?: IntFilter | number
  gender?: StringFilter | string
  dob?: StringFilter | string
  birthCountry?: StringFilter | string
  birthState?: StringFilter | string
  maritialStatus?: StringFilter | string
  militaryStatus?: StringFilter | string
  citizenshipStatus?: StringFilter | string
  citizenshipCountry?: StringFilter | string
  visaType?: StringFilter | string
  visaPermit?: StringFilter | string
  visaCountry?: StringFilter | string
  financeId?: IntNullableFilter | number | null
  advisorId?: IntNullableFilter | number | null
}

export type StudentUpsertWithWhereUniqueWithoutFinanceInput = {
  where: StudentWhereUniqueInput
  update: StudentUpdateWithoutFinanceDataInput
  create: StudentCreateWithoutFinanceInput
}

export type StudentCreateWithoutActionItemsInput = {
  studentID: number
  profilePicURL: string
  creditsCompleted: number
  gender: string
  dob: string
  birthCountry: string
  birthState: string
  maritialStatus: string
  militaryStatus: string
  citizenshipStatus: string
  citizenshipCountry: string
  visaType: string
  visaPermit: string
  visaCountry: string
  names?: NameCreateManyWithoutStudentInput
  addresses?: AddressCreateManyWithoutStudentInput
  phonenumbers?: PhoneNumberCreateManyWithoutStudentInput
  emails?: EmailAddressCreateManyWithoutStudentInput
  contacts?: ContactCreateManyWithoutStudentInput
  finance?: FinanceCreateOneWithoutStudentInput
  advisor?: TeacherCreateOneWithoutStudentInput
  classes?: ClassCreateManyWithoutStudentsInput
}

export type StudentUpdateWithoutActionItemsDataInput = {
  studentID?: number | IntFieldUpdateOperationsInput
  profilePicURL?: string | StringFieldUpdateOperationsInput
  creditsCompleted?: number | IntFieldUpdateOperationsInput
  gender?: string | StringFieldUpdateOperationsInput
  dob?: string | StringFieldUpdateOperationsInput
  birthCountry?: string | StringFieldUpdateOperationsInput
  birthState?: string | StringFieldUpdateOperationsInput
  maritialStatus?: string | StringFieldUpdateOperationsInput
  militaryStatus?: string | StringFieldUpdateOperationsInput
  citizenshipStatus?: string | StringFieldUpdateOperationsInput
  citizenshipCountry?: string | StringFieldUpdateOperationsInput
  visaType?: string | StringFieldUpdateOperationsInput
  visaPermit?: string | StringFieldUpdateOperationsInput
  visaCountry?: string | StringFieldUpdateOperationsInput
  names?: NameUpdateManyWithoutStudentInput
  addresses?: AddressUpdateManyWithoutStudentInput
  phonenumbers?: PhoneNumberUpdateManyWithoutStudentInput
  emails?: EmailAddressUpdateManyWithoutStudentInput
  contacts?: ContactUpdateManyWithoutStudentInput
  finance?: FinanceUpdateOneWithoutStudentInput
  advisor?: TeacherUpdateOneWithoutStudentInput
  classes?: ClassUpdateManyWithoutStudentsInput
}

export type StudentUpsertWithoutActionItemsInput = {
  update: StudentUpdateWithoutActionItemsDataInput
  create: StudentCreateWithoutActionItemsInput
}

export type StudentCreateWithoutContactsInput = {
  studentID: number
  profilePicURL: string
  creditsCompleted: number
  gender: string
  dob: string
  birthCountry: string
  birthState: string
  maritialStatus: string
  militaryStatus: string
  citizenshipStatus: string
  citizenshipCountry: string
  visaType: string
  visaPermit: string
  visaCountry: string
  names?: NameCreateManyWithoutStudentInput
  addresses?: AddressCreateManyWithoutStudentInput
  phonenumbers?: PhoneNumberCreateManyWithoutStudentInput
  emails?: EmailAddressCreateManyWithoutStudentInput
  finance?: FinanceCreateOneWithoutStudentInput
  actionItems?: ActionItemCreateManyWithoutStudentInput
  advisor?: TeacherCreateOneWithoutStudentInput
  classes?: ClassCreateManyWithoutStudentsInput
}

export type StudentUpdateWithoutContactsDataInput = {
  studentID?: number | IntFieldUpdateOperationsInput
  profilePicURL?: string | StringFieldUpdateOperationsInput
  creditsCompleted?: number | IntFieldUpdateOperationsInput
  gender?: string | StringFieldUpdateOperationsInput
  dob?: string | StringFieldUpdateOperationsInput
  birthCountry?: string | StringFieldUpdateOperationsInput
  birthState?: string | StringFieldUpdateOperationsInput
  maritialStatus?: string | StringFieldUpdateOperationsInput
  militaryStatus?: string | StringFieldUpdateOperationsInput
  citizenshipStatus?: string | StringFieldUpdateOperationsInput
  citizenshipCountry?: string | StringFieldUpdateOperationsInput
  visaType?: string | StringFieldUpdateOperationsInput
  visaPermit?: string | StringFieldUpdateOperationsInput
  visaCountry?: string | StringFieldUpdateOperationsInput
  names?: NameUpdateManyWithoutStudentInput
  addresses?: AddressUpdateManyWithoutStudentInput
  phonenumbers?: PhoneNumberUpdateManyWithoutStudentInput
  emails?: EmailAddressUpdateManyWithoutStudentInput
  finance?: FinanceUpdateOneWithoutStudentInput
  actionItems?: ActionItemUpdateManyWithoutStudentInput
  advisor?: TeacherUpdateOneWithoutStudentInput
  classes?: ClassUpdateManyWithoutStudentsInput
}

export type StudentUpsertWithoutContactsInput = {
  update: StudentUpdateWithoutContactsDataInput
  create: StudentCreateWithoutContactsInput
}

export type StudentCreateWithoutClassesInput = {
  studentID: number
  profilePicURL: string
  creditsCompleted: number
  gender: string
  dob: string
  birthCountry: string
  birthState: string
  maritialStatus: string
  militaryStatus: string
  citizenshipStatus: string
  citizenshipCountry: string
  visaType: string
  visaPermit: string
  visaCountry: string
  names?: NameCreateManyWithoutStudentInput
  addresses?: AddressCreateManyWithoutStudentInput
  phonenumbers?: PhoneNumberCreateManyWithoutStudentInput
  emails?: EmailAddressCreateManyWithoutStudentInput
  contacts?: ContactCreateManyWithoutStudentInput
  finance?: FinanceCreateOneWithoutStudentInput
  actionItems?: ActionItemCreateManyWithoutStudentInput
  advisor?: TeacherCreateOneWithoutStudentInput
}

export type TeacherCreateWithoutClassInput = {
  email: string
  name: string
  Student?: StudentCreateManyWithoutAdvisorInput
}

export type StudentUpdateWithWhereUniqueWithoutClassesInput = {
  where: StudentWhereUniqueInput
  data: StudentUpdateWithoutClassesDataInput
}

export type StudentUpsertWithWhereUniqueWithoutClassesInput = {
  where: StudentWhereUniqueInput
  update: StudentUpdateWithoutClassesDataInput
  create: StudentCreateWithoutClassesInput
}

export type TeacherUpdateWithoutClassDataInput = {
  email?: string | StringFieldUpdateOperationsInput
  name?: string | StringFieldUpdateOperationsInput
  Student?: StudentUpdateManyWithoutAdvisorInput
}

export type TeacherUpsertWithoutClassInput = {
  update: TeacherUpdateWithoutClassDataInput
  create: TeacherCreateWithoutClassInput
}

export type ClassCreateWithoutTeacherInput = {
  name: string
  code: string
  title: string
  days: string
  time: string
  location: string
  students?: StudentCreateManyWithoutClassesInput
}

export type StudentCreateWithoutAdvisorInput = {
  studentID: number
  profilePicURL: string
  creditsCompleted: number
  gender: string
  dob: string
  birthCountry: string
  birthState: string
  maritialStatus: string
  militaryStatus: string
  citizenshipStatus: string
  citizenshipCountry: string
  visaType: string
  visaPermit: string
  visaCountry: string
  names?: NameCreateManyWithoutStudentInput
  addresses?: AddressCreateManyWithoutStudentInput
  phonenumbers?: PhoneNumberCreateManyWithoutStudentInput
  emails?: EmailAddressCreateManyWithoutStudentInput
  contacts?: ContactCreateManyWithoutStudentInput
  finance?: FinanceCreateOneWithoutStudentInput
  actionItems?: ActionItemCreateManyWithoutStudentInput
  classes?: ClassCreateManyWithoutStudentsInput
}

export type ClassUpdateWithWhereUniqueWithoutTeacherInput = {
  where: ClassWhereUniqueInput
  data: ClassUpdateWithoutTeacherDataInput
}

export type ClassUpsertWithWhereUniqueWithoutTeacherInput = {
  where: ClassWhereUniqueInput
  update: ClassUpdateWithoutTeacherDataInput
  create: ClassCreateWithoutTeacherInput
}

export type StudentUpdateWithWhereUniqueWithoutAdvisorInput = {
  where: StudentWhereUniqueInput
  data: StudentUpdateWithoutAdvisorDataInput
}

export type StudentUpsertWithWhereUniqueWithoutAdvisorInput = {
  where: StudentWhereUniqueInput
  update: StudentUpdateWithoutAdvisorDataInput
  create: StudentCreateWithoutAdvisorInput
}

export type NameUpdateWithoutStudentDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  type?: string | StringFieldUpdateOperationsInput
}

export type NameUpdateManyDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  type?: string | StringFieldUpdateOperationsInput
}

export type AddressUpdateWithoutStudentDataInput = {
  type?: string | StringFieldUpdateOperationsInput
  address?: string | StringFieldUpdateOperationsInput
}

export type AddressUpdateManyDataInput = {
  type?: string | StringFieldUpdateOperationsInput
  address?: string | StringFieldUpdateOperationsInput
}

export type PhoneNumberUpdateWithoutStudentDataInput = {
  type?: string | StringFieldUpdateOperationsInput
  number?: string | StringFieldUpdateOperationsInput
  ext?: string | StringFieldUpdateOperationsInput
  country?: number | IntFieldUpdateOperationsInput
  preferred?: boolean | BoolFieldUpdateOperationsInput
}

export type PhoneNumberUpdateManyDataInput = {
  type?: string | StringFieldUpdateOperationsInput
  number?: string | StringFieldUpdateOperationsInput
  ext?: string | StringFieldUpdateOperationsInput
  country?: number | IntFieldUpdateOperationsInput
  preferred?: boolean | BoolFieldUpdateOperationsInput
}

export type EmailAddressUpdateWithoutStudentDataInput = {
  type?: string | StringFieldUpdateOperationsInput
  address?: string | StringFieldUpdateOperationsInput
  preferred?: boolean | BoolFieldUpdateOperationsInput
}

export type EmailAddressUpdateManyDataInput = {
  type?: string | StringFieldUpdateOperationsInput
  address?: string | StringFieldUpdateOperationsInput
  preferred?: boolean | BoolFieldUpdateOperationsInput
}

export type ContactUpdateWithoutStudentDataInput = {
  primary?: boolean | BoolFieldUpdateOperationsInput
  name?: string | StringFieldUpdateOperationsInput
  relationship?: string | StringFieldUpdateOperationsInput
  number?: string | StringFieldUpdateOperationsInput
  ext?: number | IntFieldUpdateOperationsInput
  country?: string | StringFieldUpdateOperationsInput
}

export type ContactUpdateManyDataInput = {
  primary?: boolean | BoolFieldUpdateOperationsInput
  name?: string | StringFieldUpdateOperationsInput
  relationship?: string | StringFieldUpdateOperationsInput
  number?: string | StringFieldUpdateOperationsInput
  ext?: number | IntFieldUpdateOperationsInput
  country?: string | StringFieldUpdateOperationsInput
}

export type ActionItemUpdateWithoutStudentDataInput = {
  title?: string | StringFieldUpdateOperationsInput
  detail?: string | StringFieldUpdateOperationsInput
  completed?: boolean | BoolFieldUpdateOperationsInput
}

export type ActionItemUpdateManyDataInput = {
  title?: string | StringFieldUpdateOperationsInput
  detail?: string | StringFieldUpdateOperationsInput
  completed?: boolean | BoolFieldUpdateOperationsInput
}

export type ClassUpdateWithoutStudentsDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  code?: string | StringFieldUpdateOperationsInput
  title?: string | StringFieldUpdateOperationsInput
  days?: string | StringFieldUpdateOperationsInput
  time?: string | StringFieldUpdateOperationsInput
  location?: string | StringFieldUpdateOperationsInput
  Teacher?: TeacherUpdateOneWithoutClassInput
}

export type ClassUpdateManyDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  code?: string | StringFieldUpdateOperationsInput
  title?: string | StringFieldUpdateOperationsInput
  days?: string | StringFieldUpdateOperationsInput
  time?: string | StringFieldUpdateOperationsInput
  location?: string | StringFieldUpdateOperationsInput
}

export type StudentUpdateWithoutFinanceDataInput = {
  studentID?: number | IntFieldUpdateOperationsInput
  profilePicURL?: string | StringFieldUpdateOperationsInput
  creditsCompleted?: number | IntFieldUpdateOperationsInput
  gender?: string | StringFieldUpdateOperationsInput
  dob?: string | StringFieldUpdateOperationsInput
  birthCountry?: string | StringFieldUpdateOperationsInput
  birthState?: string | StringFieldUpdateOperationsInput
  maritialStatus?: string | StringFieldUpdateOperationsInput
  militaryStatus?: string | StringFieldUpdateOperationsInput
  citizenshipStatus?: string | StringFieldUpdateOperationsInput
  citizenshipCountry?: string | StringFieldUpdateOperationsInput
  visaType?: string | StringFieldUpdateOperationsInput
  visaPermit?: string | StringFieldUpdateOperationsInput
  visaCountry?: string | StringFieldUpdateOperationsInput
  names?: NameUpdateManyWithoutStudentInput
  addresses?: AddressUpdateManyWithoutStudentInput
  phonenumbers?: PhoneNumberUpdateManyWithoutStudentInput
  emails?: EmailAddressUpdateManyWithoutStudentInput
  contacts?: ContactUpdateManyWithoutStudentInput
  actionItems?: ActionItemUpdateManyWithoutStudentInput
  advisor?: TeacherUpdateOneWithoutStudentInput
  classes?: ClassUpdateManyWithoutStudentsInput
}

export type StudentUpdateManyDataInput = {
  studentID?: number | IntFieldUpdateOperationsInput
  profilePicURL?: string | StringFieldUpdateOperationsInput
  creditsCompleted?: number | IntFieldUpdateOperationsInput
  gender?: string | StringFieldUpdateOperationsInput
  dob?: string | StringFieldUpdateOperationsInput
  birthCountry?: string | StringFieldUpdateOperationsInput
  birthState?: string | StringFieldUpdateOperationsInput
  maritialStatus?: string | StringFieldUpdateOperationsInput
  militaryStatus?: string | StringFieldUpdateOperationsInput
  citizenshipStatus?: string | StringFieldUpdateOperationsInput
  citizenshipCountry?: string | StringFieldUpdateOperationsInput
  visaType?: string | StringFieldUpdateOperationsInput
  visaPermit?: string | StringFieldUpdateOperationsInput
  visaCountry?: string | StringFieldUpdateOperationsInput
}

export type StudentUpdateWithoutClassesDataInput = {
  studentID?: number | IntFieldUpdateOperationsInput
  profilePicURL?: string | StringFieldUpdateOperationsInput
  creditsCompleted?: number | IntFieldUpdateOperationsInput
  gender?: string | StringFieldUpdateOperationsInput
  dob?: string | StringFieldUpdateOperationsInput
  birthCountry?: string | StringFieldUpdateOperationsInput
  birthState?: string | StringFieldUpdateOperationsInput
  maritialStatus?: string | StringFieldUpdateOperationsInput
  militaryStatus?: string | StringFieldUpdateOperationsInput
  citizenshipStatus?: string | StringFieldUpdateOperationsInput
  citizenshipCountry?: string | StringFieldUpdateOperationsInput
  visaType?: string | StringFieldUpdateOperationsInput
  visaPermit?: string | StringFieldUpdateOperationsInput
  visaCountry?: string | StringFieldUpdateOperationsInput
  names?: NameUpdateManyWithoutStudentInput
  addresses?: AddressUpdateManyWithoutStudentInput
  phonenumbers?: PhoneNumberUpdateManyWithoutStudentInput
  emails?: EmailAddressUpdateManyWithoutStudentInput
  contacts?: ContactUpdateManyWithoutStudentInput
  finance?: FinanceUpdateOneWithoutStudentInput
  actionItems?: ActionItemUpdateManyWithoutStudentInput
  advisor?: TeacherUpdateOneWithoutStudentInput
}

export type ClassUpdateWithoutTeacherDataInput = {
  name?: string | StringFieldUpdateOperationsInput
  code?: string | StringFieldUpdateOperationsInput
  title?: string | StringFieldUpdateOperationsInput
  days?: string | StringFieldUpdateOperationsInput
  time?: string | StringFieldUpdateOperationsInput
  location?: string | StringFieldUpdateOperationsInput
  students?: StudentUpdateManyWithoutClassesInput
}

export type StudentUpdateWithoutAdvisorDataInput = {
  studentID?: number | IntFieldUpdateOperationsInput
  profilePicURL?: string | StringFieldUpdateOperationsInput
  creditsCompleted?: number | IntFieldUpdateOperationsInput
  gender?: string | StringFieldUpdateOperationsInput
  dob?: string | StringFieldUpdateOperationsInput
  birthCountry?: string | StringFieldUpdateOperationsInput
  birthState?: string | StringFieldUpdateOperationsInput
  maritialStatus?: string | StringFieldUpdateOperationsInput
  militaryStatus?: string | StringFieldUpdateOperationsInput
  citizenshipStatus?: string | StringFieldUpdateOperationsInput
  citizenshipCountry?: string | StringFieldUpdateOperationsInput
  visaType?: string | StringFieldUpdateOperationsInput
  visaPermit?: string | StringFieldUpdateOperationsInput
  visaCountry?: string | StringFieldUpdateOperationsInput
  names?: NameUpdateManyWithoutStudentInput
  addresses?: AddressUpdateManyWithoutStudentInput
  phonenumbers?: PhoneNumberUpdateManyWithoutStudentInput
  emails?: EmailAddressUpdateManyWithoutStudentInput
  contacts?: ContactUpdateManyWithoutStudentInput
  finance?: FinanceUpdateOneWithoutStudentInput
  actionItems?: ActionItemUpdateManyWithoutStudentInput
  classes?: ClassUpdateManyWithoutStudentsInput
}

/**
 * Batch Payload for updateMany & deleteMany
 */

export type BatchPayload = {
  count: number
}

/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
